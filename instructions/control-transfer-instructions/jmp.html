<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js ayu">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>JMP - x86-64 Simplified</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../../prefix.html">Prefix</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="../../registers.html">Registers</a></li><li class="chapter-item expanded "><a href="../../flags.html">Flags</a></li><li class="chapter-item expanded "><a href="../../condition-codes.html">Condition Codes</a></li><li class="chapter-item expanded "><a href="../../instructions/README.html">Instructions</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../instructions/data-transfer-instructions/README.html">Data Transfer Instructions</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../instructions/data-transfer-instructions/mov.html">MOV</a></li><li class="chapter-item "><a href="../../instructions/data-transfer-instructions/xchg.html">XCHG</a></li><li class="chapter-item "><a href="../../instructions/data-transfer-instructions/push.html">PUSH</a></li><li class="chapter-item "><a href="../../instructions/data-transfer-instructions/pop.html">POP</a></li></ol></li><li class="chapter-item "><a href="../../instructions/binary-arithmetic-instructions/README.html">Binary Arithmetic Instructions</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../instructions/binary-arithmetic-instructions/add.html">ADD</a></li><li class="chapter-item "><a href="../../instructions/binary-arithmetic-instructions/sub.html">SUB</a></li><li class="chapter-item "><a href="../../instructions/binary-arithmetic-instructions/imul.html">IMUL</a></li><li class="chapter-item "><a href="../../instructions/binary-arithmetic-instructions/mul.html">MUL</a></li><li class="chapter-item "><a href="../../instructions/binary-arithmetic-instructions/idiv.html">IDIV</a></li><li class="chapter-item "><a href="../../instructions/binary-arithmetic-instructions/div.html">DIV</a></li><li class="chapter-item "><a href="../../instructions/binary-arithmetic-instructions/inc.html">INC</a></li><li class="chapter-item "><a href="../../instructions/binary-arithmetic-instructions/dec.html">DEC</a></li><li class="chapter-item "><a href="../../instructions/binary-arithmetic-instructions/neg.html">NEG</a></li><li class="chapter-item "><a href="../../instructions/binary-arithmetic-instructions/cmp.html">CMP</a></li></ol></li><li class="chapter-item "><a href="../../instructions/logical-instructions/README.html">Logical Instructions</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../instructions/logical-instructions/and.html">AND</a></li><li class="chapter-item "><a href="../../instructions/logical-instructions/or.html">OR</a></li><li class="chapter-item "><a href="../../instructions/logical-instructions/xor.html">XOR</a></li><li class="chapter-item "><a href="../../instructions/logical-instructions/not.html">NOT</a></li></ol></li><li class="chapter-item "><a href="../../instructions/shift-and-rotate-instructions/README.html">Shift and Rotate Instructions</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../instructions/shift-and-rotate-instructions/sal,sar,shl,shr.html">SAL|SAR|SHL|SHR</a></li></ol></li><li class="chapter-item "><a href="../../instructions/bit-and-byte-instructions/README.html">Bit and Byte Instructions</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../instructions/bit-and-byte-instructions/test.html">TEST</a></li></ol></li><li class="chapter-item expanded "><a href="../../instructions/control-transfer-instructions/README.html">Control Transfer Instructions</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../instructions/control-transfer-instructions/jmp.html" class="active">JMP</a></li><li class="chapter-item "><a href="../../instructions/control-transfer-instructions/jcc.html">Jcc</a></li><li class="chapter-item "><a href="../../instructions/control-transfer-instructions/call.html">CALL</a></li><li class="chapter-item "><a href="../../instructions/control-transfer-instructions/ret.html">RET</a></li></ol></li><li class="chapter-item "><a href="../../instructions/miscellaneous-instructions/README.html">Miscellaneous Instructions</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../instructions/miscellaneous-instructions/lea.html">LEA</a></li><li class="chapter-item "><a href="../../instructions/miscellaneous-instructions/nop.html">NOP</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../../system-v-abi.html">System V ABI</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu (default)</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">x86-64 Simplified</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Treeniks/x86-64-simplified" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="jmp"><a class="header" href="#jmp"><code>JMP</code></a></h1>
<p>Jump</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Instruction</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>JMP rel8</code></td><td style="text-align: left">Jump short, <code>RIP</code> = <code>RIP</code> + 8-bit displacement sign-extended to 64-bits</td></tr>
<tr><td style="text-align: left"><code>JMP rel16</code></td><td style="text-align: left">Jump near, relative, displacement relative to next instruction; Not supported in 64-bit mode</td></tr>
<tr><td style="text-align: left"><code>JMP rel32</code></td><td style="text-align: left">Jump near, realtive, <code>RIP</code> = <code>RIP</code> + 32-bit displacement sign-extended to 64-bits</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>JMP r/m16</code></td><td style="text-align: left">Jump near, absolute indirect, address = zer-extended <code>r/m16</code>; Not supported in 64-bit mode</td></tr>
<tr><td style="text-align: left"><code>JMP r/m32</code></td><td style="text-align: left">Jump near, absolute indirect, address given in <code>r/m32</code>; Not supported in 64-bit mode</td></tr>
<tr><td style="text-align: left"><code>JMP r/m64</code></td><td style="text-align: left">Jump near, absolute indirect, <code>RIP</code> = 64-bit offset from register or memory</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>JMP ptr16:16</code></td><td style="text-align: left">Jump far, absolute, address given in operand</td></tr>
<tr><td style="text-align: left"><code>JMP ptr16:32</code></td><td style="text-align: left">Jump far, absolute, address given in operand</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>JMP m16:16</code></td><td style="text-align: left">Jump far, absolute indirect, address given in operand</td></tr>
<tr><td style="text-align: left"><code>JMP m16:32</code></td><td style="text-align: left">Jump far, absolute indirect, address given in operand</td></tr>
<tr><td style="text-align: left"><code>JMP m16:64</code></td><td style="text-align: left">Jump far, absolute indirect, address given in operand</td></tr>
</tbody></table>
</div>
<h2 id="description"><a class="header" href="#description">Description</a></h2>
<p>Transfers program control to a different point in the instruction stream without recording return information. The destination (target) operand specifies the address of the instruction being jumped to. This operand can be an immediate value, a general-purpose register, or a memory location.</p>
<p>This instruction can be used to execute four different types of jumps:</p>
<ul>
<li><strong>Near jump</strong><br />
A jump to an instruction within the current code segment (the segment currently pointed to by the <code>CS</code> register), sometimes referred to as an intrasegment jump.</li>
<li><strong>Short jump</strong><br />
A near jump where the jump range is limited to –128 to +127 from the current <code>EIP</code> value.</li>
<li><strong>Far jump</strong><br />
A jump to an instruction located in a different segment than the current code segment but at the same privilege level, sometimes referred to as an intersegment jump.</li>
<li><strong>Task switch</strong><br />
A jump to an instruction located in a different task.
A task switch can only be executed in protected mode (see Chapter 7, in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A, for information on performing task switches with the JMP instruction).</li>
</ul>
<h3 id="near-and-short-jumps"><a class="header" href="#near-and-short-jumps">Near and Short Jumps</a></h3>
<p>When executing a near jump, the processor jumps to the address (within the current code segment) that is specified with the target operand. The target operand specifies either an absolute offset (that is an offset from the base of the code segment) or a relative offset (a signed displacement relative to the current value of the instruction pointer in the <code>EIP</code> register). A near jump to a relative offset of 8-bits (<code>rel8</code>) is referred to as a short jump. The <code>CS</code> register is not changed on near and short jumps.</p>
<p>An absolute offset is specified indirectly in a general-purpose register or a memory location (<code>r/m16</code> or <code>r/m32</code>). The operand-size attribute determines the size of the target operand (16 or 32 bits). Absolute offsets are loaded directly into the <code>EIP</code> register. If the operand-size attribute is 16, the upper two bytes of the <code>EIP</code> register are cleared, resulting in a maximum instruction pointer size of 16 bits.</p>
<p>A relative offset (<code>rel8</code>, <code>rel16</code>, or <code>rel32</code>) is generally specified as a label in assembly code, but at the machine code level, it is encoded as a signed 8-, 16-, or 32-bit immediate value. This value is added to the value in the <code>EIP</code> register. (Here, the <code>EIP</code> register contains the address of the instruction following the <code>JMP</code> instruction). When using relative offsets, the opcode (for short vs. near jumps) and the operand-size attribute (for near relative jumps) determines the size of the target operand (8, 16, or 32 bits).</p>
<h3 id="far-jumps-in-real-address-or-virtual-8086-mode"><a class="header" href="#far-jumps-in-real-address-or-virtual-8086-mode">Far Jumps in Real-Address or Virtual-8086 Mode</a></h3>
<p>When executing a far jump in real-address or virtual-8086 mode, the processor jumps to the code segment and offset specified with the target operand. Here the target operand specifies an absolute far address either directly with a pointer (<code>ptr16:16</code> or <code>ptr16:32</code>) or indirectly with a memory location (<code>m16:16</code> or <code>m16:32</code>). With the pointer method, the segment and address of the called procedure is encoded in the instruction, using a 4-byte (16-bit operand size) or 6-byte (32-bit operand size) far address immediate. With the indirect method, the target operand specifies a memory location that contains a 4-byte (16-bit operand size) or 6-byte (32-bit operand size) far address. The far address is loaded directly into the <code>CS</code> and <code>EIP</code> registers. If the operand-size attribute is 16, the upper two bytes of the <code>EIP</code> register are cleared.</p>
<h3 id="far-jumps-in-protected-mode"><a class="header" href="#far-jumps-in-protected-mode">Far Jumps in Protected Mode</a></h3>
<p>When the processor is operating in protected mode, the <code>JMP</code> instruction can be used to perform the following three types of far jumps:</p>
<ul>
<li>A far jump to a conforming or non-conforming code segment.</li>
<li>A far jump through a call gate.</li>
<li>A task switch.
(The <code>JMP</code> instruction cannot be used to perform inter-privilege-level far jumps.)</li>
</ul>
<p>In protected mode, the processor always uses the segment selector part of the far address to access the corresponding descriptor in the <code>GDT</code> or <code>LDT</code>. The descriptor type (code segment, call gate, task gate, or <code>TSS</code>) and access rights determine the type of jump to be performed.</p>
<p>If the selected descriptor is for a code segment, a far jump to a code segment at the same privilege level is performed. (If the selected code segment is at a different privilege level and the code segment is non-conforming, a general-protection exception is generated.) A far jump to the same privilege level in protected mode is very similar to one carried out in real-address or virtual-8086 mode. The target operand specifies an absolute far address either directly with a pointer (<code>ptr16:16</code> or <code>ptr16:32</code>) or indirectly with a memory location (<code>m16:16</code> or <code>m16:32</code>). The operand-size attribute determines the size of the offset (16 or 32 bits) in the far address. The new code segment selector and its descriptor are loaded into <code>CS</code> register, and the offset from the instruction is loaded into the <code>EIP</code> register. Note that a call gate (described in the next paragraph) can also be used to perform far call to a code segment at the same privilege level. Using this mechanism provides an extra level of indirection and is the preferred method of making jumps between 16-bit and 32-bit code segments.</p>
<p>When executing a far jump through a call gate, the segment selector specified by the target operand identifies the call gate. (The offset part of the target operand is ignored.) The processor then jumps to the code segment specified in the call gate descriptor and begins executing the instruction at the offset specified in the call gate. No stack switch occurs. Here again, the target operand can specify the far address of the call gate either directly with a pointer (<code>ptr16:16</code> or <code>ptr16:32</code>) or indirectly with a memory location (<code>m16:16</code> or <code>m16:32</code>).</p>
<p>Executing a task switch with the <code>JMP</code> instruction is somewhat similar to executing a jump through a call gate. Here the target operand specifies the segment selector of the task gate for the task being switched to (and the offset part of the target operand is ignored). The task gate in turn points to the <code>TSS</code> for the task, which contains the segment selectors for the task’s code and stack segments. The <code>TSS</code> also contains the <code>EIP</code> value for the next instruction that was to be executed before the task was suspended. This instruction pointer value is loaded into the <code>EIP</code> register so that the task begins executing again at this next instruction.</p>
<p>The <code>JMP</code> instruction can also specify the segment selector of the <code>TSS</code> directly, which eliminates the indirection of the task gate. See Chapter 7 in Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A, for detailed information on the mechanics of a task switch.</p>
<p>Note that when you execute at task switch with a <code>JMP</code> instruction, the nested task flag (<code>NT</code>) is not set in the <code>EFLAGS</code> register and the new <code>TSS</code>’s previous task link field is not loaded with the old task’s <code>TSS</code> selector. A return to the previous task can thus not be carried out by executing the <code>IRET</code> instruction. Switching tasks with the <code>JMP</code> instruction differs in this regard from the <code>CALL</code> instruction which does set the <code>NT</code> flag and save the previous task link information, allowing a return to the calling task with an <code>IRET</code> instruction.</p>
<p>Refer to Chapter 6, “Procedure Calls, Interrupts, and Exceptions” and Chapter 18, “Control-Flow Enforcement
Technology (CET)” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1 for <code>CET</code>
details.</p>
<h3 id="in-64-bit-mode"><a class="header" href="#in-64-bit-mode">In 64-Bit Mode</a></h3>
<p>The instruction’s operation size is fixed at 64 bits. If a selector points to a gate, then <code>RIP</code> equals the 64-bit displacement taken from gate; else <code>RIP</code> equals the zero-extended offset from the far pointer referenced in the instruction.</p>
<p>See the summary chart at the beginning of this section for encoding data and limits.</p>
<h3 id="instruction-ordering"><a class="header" href="#instruction-ordering">Instruction ordering</a></h3>
<p>Instructions following a far jump may be fetched from memory before earlier instructions complete execution, but they will not execute (even speculatively) until all instructions prior to the far jump have completed execution (the later instructions may execute before data stored by the earlier instructions have become globally visible).</p>
<p>Certain situations may lead to the next sequential instruction after a near indirect <code>JMP</code> being speculatively executed. If software needs to prevent this (e.g., in order to prevent a speculative execution side channel), then an <code>INT3</code> or <code>LFENCE</code> instruction opcode can be placed after the near indirect <code>JMP</code> in order to block speculative execution.</p>
<h2 id="operation"><a class="header" href="#operation">Operation</a></h2>
<pre><code class="language-rust ignore">if /* near jump */ {
    if /* 64-bit Mode */ {
        if /* near relative jump */ {
            // RIP is instruction following JMP instruction
            tempRIP = RIP + DEST;
        } else {
            // near absolute jump
            tempRIP = DEST;
        }
    } else {
        if /* near relative jump */ {
            // EIP is instruction following JMP instruction
            tempEIP = EIP + DEST;
        } else {
            // near absolute jump
            tempEIP = DEST;
        }
    }
    if (IA32_EFER.LMA == 0 || target mode == Compatibility mode)
            &amp;&amp; /* tempEIP outside code segment limit */ {
        #GP(0);
    }
    if /* 64-bit mode and tempRIP is not canonical */ {
        #GP(0);
    }
    if OperandSize == 32 {
        EIP = tempEIP;
    } else {
        if OperandSize == 16 {
            EIP = tempEIP &amp; 0x0000_FFFF;
        } else {
            // OperandSize == 64
            RIP = tempRIP;
        }
    }
    if /* JMP near indirect, absolute indirect */ {
        if EndbranchEnabledAndNotSuppressed(CPL) {
            if CPL == 3 {
                if /* no 3EH prefix */ || IA32_U_CET.NO_TRACK_EN == 0 {
                    IA32_U_CET.TRACKER = WAIT_FOR_ENDBRANCH;
                }
            } else {
                if /* no 3EH prefix */ || IA32_S_CET.NO_TRACK_EN == 0 {
                    IA32_S_CET.TRACKER = WAIT_FOR_ENDBRANCH;
                }
            }
        }
    }
}

if /* far jump */ &amp;&amp; (PE == 0 || (PE == 1 &amp;&amp; VM == 1)) {
    // real-address or virtual-8086 mode
    tempEIP = DEST(Offset); // DEST is ptr16:32 or [m16:32]
    if /* tempEIP is beyond code segment limit */ {
        #GP(0);
    }
    CS = DEST(segment selector); // DEST is ptr16:32 or [m16:32]
    if OperandSize == 32 {
        EIP = tempEIP; // DEST is ptr16:32 or [m16:32]
    } else {
        // OperandSize == 16
        EIP = tempEIP &amp; 0x0000_FFFF; // clear upper 16 bits
    }
}

if /* far jump */ &amp;&amp; PE == 1 &amp;&amp; VM == 0 {
    // IA-32e mode or protected mode, not virtual-8086 mode
    if /* effective address in the CS, DS, ES, FS, GS, or SS segment is illegal
            or segment selector in target operand NULL */ {
        #GP(0);
    }
    if /* segment selector index not within descriptor table limits */ {
        #GP(new selector);
    }
    /* read type and access rights of segment descriptor; */
    if IA32_EFER.LMA == 0 {
        if /* segment type is not a conforming or nonconforming code
                segment, call gate, task gate, or TSS */ {
            #GP(segment selector);
        }
    } else {
        if /* segment type is not a conforming or nonconforming code segment
                call gate */ {
            #GP(segment selector);
        }
    }
    /* Depending on type and access rights: */
        goto 'CONFORMING_CODE_SEGMENT;
        goto 'NONCONFORMING_CODE_SEGMENT;
        goto 'CALL_GATE;
        goto 'TASK_GATE;
        goto 'TASK_STATE_SEGMENT;
} else {
    #GP(segment selector);
}

'CONFORMING_CODE_SEGMENT {
    if L-Bit == 1 &amp;&amp; D-BIT == 1 &amp;&amp; IA32_EFER.LMA == 1 {
        #GP(new code segment selector);
    }
    if DPL &gt; CPL {
        #GP(segment selector);
    }
    if /* segment not present */ {
        #NP(segment selector);
    }
    tempEIP = DEST(Offset);
    if OperandSize == 16 {
        tempEIP = tempEIP &amp; 0x0000_FFFF;
    }
    if (IA32_EFER.LMA == 0 || target mode == Compatibility mode)
            &amp;&amp; /* tempEIP outside code segment limit */ {
        #GP(0);
    }
    if /* tempEIP is non-canonical */ {
        #GP(0);
    }
    if ShadowStackEnabled(CPL) {
        if (IA32_EFER.LMA &amp; DEST(segment selector).L) == 0 {
            // if target is legacy or compatibility mode then the SSP must be in low 4GB
            if SSP &amp; 0xFFFF_FFFF_0000_0000 != 0
                #GP(0);
            FI;
        }
    }
    CS = DEST[segment selector]; // segment descriptor information also loaded
    CS(RPL) = CPL
    EIP = tempEIP;
    if EndbranchEnabled(CPL) {
        if CPL = 3 {
            IA32_U_CET.TRACKER = WAIT_FOR_ENDBRANCH;
            IA32_U_CET.SUPPRESS = 0;
        } else {
            IA32_S_CET.TRACKER = WAIT_FOR_ENDBRANCH;
            IA32_S_CET.SUPPRESS = 0;
        }
    }
}

'NONCONFORMING_CODE_SEGMENT {
    if L-Bit == 1 &amp;&amp; D-BIT == 1 &amp;&amp; IA32_EFER.LMA == 1 {
        #GP(new code segment selector);
    }
    if (RPL &gt; CPL) || (DPL != CPL) {
        #GP(code segment selector);
    }
    if /* segment not present */ {
        #NP(segment selector);
    }
    tempEIP = DEST(Offset);
    if OperandSize == 16 {
        tempEIP = tempEIP &amp; 0x0000_FFFF;
    }
    if (IA32_EFER.LMA == 0 || target mode == Compatibility mode)
            &amp;&amp; /* tempEIP outside code segment limit */ {
        #GP(0);
    }
    if /* tempEIP is non-canonical */ {
        #GP(0);
    }
    if ShadowStackEnabled(CPL) {
        if (IA32_EFER.LMA &amp; DEST(segment selector).L) == 0 {
            // if target is legacy or compatibility mode then the SSP must be in low 4GB
            if (SSP &amp; 0xFFFF_FFFF_0000_0000 != 0) {
                #GP(0);
            }
        }
    }
    CS = DEST[segment selector]; // segment descriptor information also loaded
    CS(RPL) = CPL;
    EIP = tempEIP;
    if EndbranchEnabled(CPL) {
        if CPL == 3 {
            IA32_U_CET.TRACKER = WAIT_FOR_ENDBRANCH;
            IA32_U_CET.SUPPRESS = 0;
        } else {
            IA32_S_CET.TRACKER = WAIT_FOR_ENDBRANCH;
            IA32_S_CET.SUPPRESS = 0;
        }
    }
}

'CALL_GATE {
    if call gate DPL &lt; CPL
            || call gate DPL &lt; call gate segment-selector RPL {
        #GP(call gate selector);
    }
    if /* call gate not present */ {
        #NP(call gate selector);
    }
    if /* call gate code-segment selector is NULL */ {
        #GP(0);
    }
    if /* call gate code-segment selector index outside descriptor table limits */ {
        #GP(code segment selector);
    }
    /* Read code segment descriptor; */
    if /* code-segment segment descriptor does not indicate a code segment */
            || (/* code-segment segment descriptor is conforming */ &amp;&amp; DPL &gt; CPL)
            || (/* code-segment segment descriptor is non-conforming */ &amp;&amp; DPL != CPL)
        #GP(code segment selector);
    }
    if IA32_EFER.LMA == 1 &amp;&amp; (/* code-segment descriptor is not a 64-bit code segment */
            || /* code-segment segment descriptor has both L-Bit and D-bit set */) {
        #GP(code segment selector);
    }
    if /* code segment is not present */ {
        #NP(code-segment selector);
    }
    tempEIP = DEST(Offset);
    if GateSize == 16 {
        tempEIP = tempEIP &amp; 0x0000_FFFF;
    }
    if (IA32_EFER.LMA == 0 || target mode == Compatibility mode)
            &amp;&amp; /* tempEIP outside code segment limit */ {
        #GP(0);
    }
    CS = DEST[SegmentSelector]; // segment descriptor information also loaded
    CS(RPL) = CPL;
    EIP = tempEIP;
    if EndbranchEnabled(CPL) {
        if CPL == 3 {
            IA32_U_CET.TRACKER = WAIT_FOR_ENDBRANCH;
            IA32_U_CET.SUPPRESS = 0;
        } else {
            IA32_S_CET.TRACKER = WAIT_FOR_ENDBRANCH;
            IA32_S_CET.SUPPRESS = 0;
        }
    }
}

'TASK_GATE {
    if task gate DPL &lt; CPL
            || task gate DPL &lt; task gate segment-selector RPL {
        #GP(task gate selector);
    }
    if /* task gate not present */ {
        #NP(gate selector);
    }
    /* Read the TSS segment selector in the task-gate descriptor; */
    if /* TSS segment selector local/global bit is set to local */
            || /* index not within GDT limits */
            || /* descriptor is not a TSS segment */
            || /* TSS descriptor specifies that the TSS is busy */ {
        #GP(TSS selector);
    }
    if /* TSS not present */ {
        #NP(TSS selector);
    }
    SWITCH-TASKS to TSS;
    if /* EIP not within code segment limit */ {
        #GP(0);
    }
}

'TASK_STATE_SEGMENT {
    if TSS DPL &lt; CPL
            || TSS DPL &lt; TSS segment-selector RPL
            || /* TSS descriptor indicates TSS not available */ {
        #GP(TSS selector);
    }
    if /* TSS is not present */ {
        #NP(TSS selector);
    }
    SWITCH-TASKS to TSS;
    if /* EIP not within code segment limit */
        #GP(0);
    }
}
</code></pre>
<h2 id="flags-affected"><a class="header" href="#flags-affected">Flags Affected</a></h2>
<p>All flags are affected if a task switch occurs; no flags are affected if a task switch does not occur.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../instructions/control-transfer-instructions/README.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../../instructions/control-transfer-instructions/jcc.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../instructions/control-transfer-instructions/README.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../../instructions/control-transfer-instructions/jcc.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
