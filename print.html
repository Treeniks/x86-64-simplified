<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js ayu">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>x86-64 Simplified</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="prefix.html">Prefix</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="registers.html">Registers</a></li><li class="chapter-item expanded "><a href="flags.html">Flags</a></li><li class="chapter-item expanded "><a href="condition-codes.html">Condition Codes</a></li><li class="chapter-item expanded "><a href="instructions/README.html">Instructions</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="instructions/data-transfer-instructions/README.html">Data Transfer Instructions</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="instructions/data-transfer-instructions/mov.html">MOV</a></li><li class="chapter-item "><a href="instructions/data-transfer-instructions/xchg.html">XCHG</a></li><li class="chapter-item "><a href="instructions/data-transfer-instructions/push.html">PUSH</a></li><li class="chapter-item "><a href="instructions/data-transfer-instructions/pop.html">POP</a></li></ol></li><li class="chapter-item "><a href="instructions/binary-arithmetic-instructions/README.html">Binary Arithmetic Instructions</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="instructions/binary-arithmetic-instructions/add.html">ADD</a></li><li class="chapter-item "><a href="instructions/binary-arithmetic-instructions/sub.html">SUB</a></li><li class="chapter-item "><a href="instructions/binary-arithmetic-instructions/imul.html">IMUL</a></li><li class="chapter-item "><a href="instructions/binary-arithmetic-instructions/mul.html">MUL</a></li><li class="chapter-item "><a href="instructions/binary-arithmetic-instructions/idiv.html">IDIV</a></li><li class="chapter-item "><a href="instructions/binary-arithmetic-instructions/div.html">DIV</a></li><li class="chapter-item "><a href="instructions/binary-arithmetic-instructions/inc.html">INC</a></li><li class="chapter-item "><a href="instructions/binary-arithmetic-instructions/dec.html">DEC</a></li><li class="chapter-item "><a href="instructions/binary-arithmetic-instructions/neg.html">NEG</a></li><li class="chapter-item "><a href="instructions/binary-arithmetic-instructions/cmp.html">CMP</a></li></ol></li><li class="chapter-item "><a href="instructions/logical-instructions/README.html">Logical Instructions</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="instructions/logical-instructions/and.html">AND</a></li><li class="chapter-item "><a href="instructions/logical-instructions/or.html">OR</a></li><li class="chapter-item "><a href="instructions/logical-instructions/xor.html">XOR</a></li><li class="chapter-item "><a href="instructions/logical-instructions/not.html">NOT</a></li></ol></li><li class="chapter-item "><a href="instructions/shift-and-rotate-instructions/README.html">Shift and Rotate Instructions</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="instructions/shift-and-rotate-instructions/sal,sar,shl,shr.html">SAL|SAR|SHL|SHR</a></li></ol></li><li class="chapter-item "><a href="instructions/bit-and-byte-instructions/README.html">Bit and Byte Instructions</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="instructions/bit-and-byte-instructions/test.html">TEST</a></li></ol></li><li class="chapter-item "><a href="instructions/control-transfer-instructions/README.html">Control Transfer Instructions</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="instructions/control-transfer-instructions/jmp.html">JMP</a></li><li class="chapter-item "><a href="instructions/control-transfer-instructions/jcc.html">Jcc</a></li><li class="chapter-item "><a href="instructions/control-transfer-instructions/call.html">CALL</a></li><li class="chapter-item "><a href="instructions/control-transfer-instructions/ret.html">RET</a></li></ol></li><li class="chapter-item "><a href="instructions/miscellaneous-instructions/README.html">Miscellaneous Instructions</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="instructions/miscellaneous-instructions/lea.html">LEA</a></li><li class="chapter-item "><a href="instructions/miscellaneous-instructions/nop.html">NOP</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="system-v-abi.html">System V ABI</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu (default)</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">x86-64 Simplified</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Treeniks/x86-64-simplified" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="prefix"><a class="header" href="#prefix">Prefix</a></h1>
<p>This is a very opinionated alternative Instruction Set Reference for the x86-64 Architecture written in <a href="https://github.com/rust-lang/mdBook">mdbook</a>.</p>
<p>The goal of this reference is to prioritize readability and simplicity over accuracy or completeness. Thus, for any project with stakes or anything that requires more complicated instructions, grab the <a href="https://software.intel.com/content/www/us/en/develop/articles/intel-sdm.html">official Intel x86-64 Software Developer Manual</a> instead.</p>
<p>This reference is nowhere near finished. Most Instructions are missing and some of the ones that are included have only been slightly altered from the original Intel Manual. The end goal is to give simple examples and simplify the Operation Pseudocode enough to make it easy and understandable for Assembly beginners, who, for example, wouldn’t care much about the specific opcode encoding of instructions.</p>
<p>From my personal experience using the Intel Manual, it is littered with inconsistencies and often annoyingly complicated tech-talk that will do nothing but confuse newbies, which is the reason I created this book.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="registers"><a class="header" href="#registers">Registers</a></h1>
<h2 id="x86-64"><a class="header" href="#x86-64">x86-64</a></h2>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">64-bit</th><th style="text-align: left">32-bit</th><th style="text-align: left">16-bit</th><th style="text-align: left">8-bit high</th><th style="text-align: left">8-bit low</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>rax</code></td><td style="text-align: left"><code>eax</code></td><td style="text-align: left"><code>ax</code></td><td style="text-align: left"><code>ah</code></td><td style="text-align: left"><code>al</code></td></tr>
<tr><td style="text-align: left"><code>rbx</code></td><td style="text-align: left"><code>ebx</code></td><td style="text-align: left"><code>bx</code></td><td style="text-align: left"><code>bh</code></td><td style="text-align: left"><code>bl</code></td></tr>
<tr><td style="text-align: left"><code>rcx</code></td><td style="text-align: left"><code>ecx</code></td><td style="text-align: left"><code>cx</code></td><td style="text-align: left"><code>ch</code></td><td style="text-align: left"><code>cl</code></td></tr>
<tr><td style="text-align: left"><code>rdx</code></td><td style="text-align: left"><code>edx</code></td><td style="text-align: left"><code>dx</code></td><td style="text-align: left"><code>dh</code></td><td style="text-align: left"><code>dl</code></td></tr>
<tr><td style="text-align: left"><code>rdi</code></td><td style="text-align: left"><code>edi</code></td><td style="text-align: left"><code>di</code></td><td style="text-align: left"></td><td style="text-align: left"><code>dil</code></td></tr>
<tr><td style="text-align: left"><code>rsi</code></td><td style="text-align: left"><code>esi</code></td><td style="text-align: left"><code>si</code></td><td style="text-align: left"></td><td style="text-align: left"><code>sil</code></td></tr>
<tr><td style="text-align: left"><code>rbp</code></td><td style="text-align: left"><code>ebp</code></td><td style="text-align: left"><code>bp</code></td><td style="text-align: left"></td><td style="text-align: left"><code>bpl</code></td></tr>
<tr><td style="text-align: left"><code>rsp</code></td><td style="text-align: left"><code>esp</code></td><td style="text-align: left"><code>sp</code></td><td style="text-align: left"></td><td style="text-align: left"><code>spl</code></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>r8</code></td><td style="text-align: left"><code>r8d</code></td><td style="text-align: left"><code>r8w</code></td><td style="text-align: left"></td><td style="text-align: left"><code>r8b</code></td></tr>
<tr><td style="text-align: left"><code>r9</code></td><td style="text-align: left"><code>r9d</code></td><td style="text-align: left"><code>r9w</code></td><td style="text-align: left"></td><td style="text-align: left"><code>r9b</code></td></tr>
<tr><td style="text-align: left"><code>r10</code></td><td style="text-align: left"><code>r10d</code></td><td style="text-align: left"><code>r10w</code></td><td style="text-align: left"></td><td style="text-align: left"><code>r10b</code></td></tr>
<tr><td style="text-align: left"><code>r11</code></td><td style="text-align: left"><code>r11d</code></td><td style="text-align: left"><code>r11w</code></td><td style="text-align: left"></td><td style="text-align: left"><code>r11b</code></td></tr>
<tr><td style="text-align: left"><code>r12</code></td><td style="text-align: left"><code>r12d</code></td><td style="text-align: left"><code>r12w</code></td><td style="text-align: left"></td><td style="text-align: left"><code>r12b</code></td></tr>
<tr><td style="text-align: left"><code>r13</code></td><td style="text-align: left"><code>r13d</code></td><td style="text-align: left"><code>r13w</code></td><td style="text-align: left"></td><td style="text-align: left"><code>r13b</code></td></tr>
<tr><td style="text-align: left"><code>r14</code></td><td style="text-align: left"><code>r14d</code></td><td style="text-align: left"><code>r14w</code></td><td style="text-align: left"></td><td style="text-align: left"><code>r14b</code></td></tr>
<tr><td style="text-align: left"><code>r15</code></td><td style="text-align: left"><code>r15d</code></td><td style="text-align: left"><code>r15w</code></td><td style="text-align: left"></td><td style="text-align: left"><code>r15b</code></td></tr>
</tbody></table>
</div><pre class="svgbob"><style>text{fill:var(--fg)}</style><svg xmlns="http://www.w3.org/2000/svg" width="672" height="1056">
  <style>
    line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}
    <!--separator-->
    
  </style>
  <defs>
    <marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <polygon points="0,0 0,4 4,2 0,0"></polygon>
    </marker>
    <marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <polygon points="0,2 2,0 4,2 2,4 0,2"></polygon>
    </marker>
    <marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <circle cx="4" cy="4" r="2" class="filled"></circle>
    </marker>
    <marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <circle cx="4" cy="4" r="2" class="bg_filled"></circle>
    </marker>
    <marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <circle cx="4" cy="4" r="3" class="bg_filled"></circle>
    </marker>
  </defs>
  <rect class="backdrop" x="0" y="0" width="672" height="1056"></rect>
  <text x="290" y="28" >8bit</text>
  <text x="266" y="60" >16bit</text>
  <text x="226" y="92" >32bit</text>
  <text x="146" y="124" >64bit</text>
  <text x="338" y="28" >Byte</text>
  <text x="338" y="60" >Word</text>
  <text x="338" y="92" >Doubleword</text>
  <text x="338" y="124" >Quadword</text>
  <text x="274" y="204" >ax</text>
  <text x="258" y="236" >ah</text>
  <text x="298" y="236" >al</text>
  <text x="274" y="316" >bx</text>
  <text x="258" y="348" >bh</text>
  <text x="298" y="348" >bl</text>
  <text x="274" y="428" >cx</text>
  <text x="258" y="460" >ch</text>
  <text x="298" y="460" >cl</text>
  <text x="274" y="540" >dx</text>
  <text x="258" y="572" >dh</text>
  <text x="298" y="572" >dl</text>
  <text x="290" y="684" >dil</text>
  <text x="290" y="796" >sil</text>
  <text x="290" y="908" >bpl</text>
  <text x="290" y="1020" >spl</text>
  <text x="586" y="220" >r8w</text>
  <text x="626" y="236" >r8b</text>
  <text x="586" y="332" >r9w</text>
  <text x="626" y="348" >r9b</text>
  <text x="586" y="444" >r10w</text>
  <text x="626" y="460" >r10b</text>
  <text x="586" y="556" >r11w</text>
  <text x="626" y="572" >r11b</text>
  <text x="586" y="668" >r12w</text>
  <text x="626" y="684" >r12b</text>
  <text x="586" y="780" >r13w</text>
  <text x="626" y="796" >r13b</text>
  <text x="586" y="892" >r14w</text>
  <text x="626" y="908" >r14b</text>
  <text x="586" y="1004" >r15w</text>
  <text x="626" y="1020" >r15b</text>
  <text x="74" y="204" >rax</text>
  <text x="194" y="204" >eax</text>
  <text x="410" y="204" >r8</text>
  <text x="530" y="204" >r8d</text>
  <text x="74" y="316" >rbx</text>
  <text x="194" y="316" >ebx</text>
  <text x="410" y="316" >r9</text>
  <text x="530" y="316" >r9d</text>
  <text x="74" y="428" >rcx</text>
  <text x="194" y="428" >ecx</text>
  <text x="410" y="428" >r10</text>
  <text x="522" y="428" >r10d</text>
  <text x="74" y="540" >rdx</text>
  <text x="194" y="540" >edx</text>
  <text x="410" y="540" >r11</text>
  <text x="522" y="540" >r11d</text>
  <text x="74" y="652" >rdi</text>
  <text x="194" y="652" >edi</text>
  <text x="410" y="652" >r12</text>
  <text x="522" y="652" >r12d</text>
  <text x="258" y="668" >di</text>
  <text x="74" y="764" >rsi</text>
  <text x="194" y="764" >esi</text>
  <text x="410" y="764" >r13</text>
  <text x="522" y="764" >r13d</text>
  <text x="258" y="780" >si</text>
  <text x="74" y="876" >rbp</text>
  <text x="194" y="876" >ebp</text>
  <text x="410" y="876" >r14</text>
  <text x="522" y="876" >r14d</text>
  <text x="258" y="892" >bp</text>
  <text x="74" y="988" >rsp</text>
  <text x="194" y="988" >esp</text>
  <text x="410" y="988" >r15</text>
  <text x="522" y="988" >r15d</text>
  <text x="258" y="1004" >sp</text>
  <g>
    <path d="M 288,8 A 4,4 0,0,0 284,12" class="nofill"></path>
    <line x1="284" y1="12" x2="284" y2="32" class="solid"></line>
    <line x1="288" y1="8" x2="320" y2="8" class="solid"></line>
    <path d="M 320,8 A 4,4 0,0,1 324,12" class="nofill"></path>
    <line x1="324" y1="12" x2="324" y2="128" class="solid"></line>
    <path d="M 248,40 A 4,4 0,0,0 244,44" class="nofill"></path>
    <line x1="244" y1="44" x2="244" y2="64" class="solid"></line>
    <line x1="248" y1="40" x2="324" y2="40" class="solid"></line>
    <path d="M 168,72 A 4,4 0,0,0 164,76" class="nofill"></path>
    <line x1="164" y1="76" x2="164" y2="96" class="solid"></line>
    <line x1="168" y1="72" x2="324" y2="72" class="solid"></line>
    <path d="M 8,104 A 4,4 0,0,0 4,108" class="nofill"></path>
    <line x1="4" y1="108" x2="4" y2="128" class="solid"></line>
    <line x1="8" y1="104" x2="324" y2="104" class="solid"></line>
  </g>
  <g>
    <path d="M 8,152 A 4,4 0,0,0 4,156" class="nofill"></path>
    <line x1="4" y1="156" x2="4" y2="244" class="solid"></line>
    <line x1="8" y1="152" x2="320" y2="152" class="solid"></line>
    <path d="M 320,152 A 4,4 0,0,1 324,156" class="nofill"></path>
    <line x1="324" y1="156" x2="324" y2="244" class="solid"></line>
    <path d="M 4,244 A 4,4 0,0,0 8,248" class="nofill"></path>
    <path d="M 168,168 A 4,4 0,0,0 164,172" class="nofill"></path>
    <line x1="164" y1="172" x2="164" y2="248" class="solid"></line>
    <line x1="168" y1="168" x2="324" y2="168" class="solid"></line>
    <path d="M 248,184 A 4,4 0,0,0 244,188" class="nofill"></path>
    <line x1="244" y1="188" x2="244" y2="248" class="solid"></line>
    <line x1="248" y1="184" x2="324" y2="184" class="solid"></line>
    <line x1="244" y1="216" x2="324" y2="216" class="solid"></line>
    <line x1="284" y1="216" x2="284" y2="248" class="solid"></line>
    <line x1="8" y1="248" x2="320" y2="248" class="solid"></line>
    <path d="M 324,244 A 4,4 0,0,1 320,248" class="nofill"></path>
  </g>
  <g>
    <path d="M 8,264 A 4,4 0,0,0 4,268" class="nofill"></path>
    <line x1="4" y1="268" x2="4" y2="356" class="solid"></line>
    <line x1="8" y1="264" x2="320" y2="264" class="solid"></line>
    <path d="M 320,264 A 4,4 0,0,1 324,268" class="nofill"></path>
    <line x1="324" y1="268" x2="324" y2="356" class="solid"></line>
    <path d="M 4,356 A 4,4 0,0,0 8,360" class="nofill"></path>
    <path d="M 168,280 A 4,4 0,0,0 164,284" class="nofill"></path>
    <line x1="164" y1="284" x2="164" y2="360" class="solid"></line>
    <line x1="168" y1="280" x2="324" y2="280" class="solid"></line>
    <path d="M 248,296 A 4,4 0,0,0 244,300" class="nofill"></path>
    <line x1="244" y1="300" x2="244" y2="360" class="solid"></line>
    <line x1="248" y1="296" x2="324" y2="296" class="solid"></line>
    <line x1="244" y1="328" x2="324" y2="328" class="solid"></line>
    <line x1="284" y1="328" x2="284" y2="360" class="solid"></line>
    <line x1="8" y1="360" x2="320" y2="360" class="solid"></line>
    <path d="M 324,356 A 4,4 0,0,1 320,360" class="nofill"></path>
  </g>
  <g>
    <path d="M 8,376 A 4,4 0,0,0 4,380" class="nofill"></path>
    <line x1="4" y1="380" x2="4" y2="468" class="solid"></line>
    <line x1="8" y1="376" x2="320" y2="376" class="solid"></line>
    <path d="M 320,376 A 4,4 0,0,1 324,380" class="nofill"></path>
    <line x1="324" y1="380" x2="324" y2="468" class="solid"></line>
    <path d="M 4,468 A 4,4 0,0,0 8,472" class="nofill"></path>
    <path d="M 168,392 A 4,4 0,0,0 164,396" class="nofill"></path>
    <line x1="164" y1="396" x2="164" y2="472" class="solid"></line>
    <line x1="168" y1="392" x2="324" y2="392" class="solid"></line>
    <path d="M 248,408 A 4,4 0,0,0 244,412" class="nofill"></path>
    <line x1="244" y1="412" x2="244" y2="472" class="solid"></line>
    <line x1="248" y1="408" x2="324" y2="408" class="solid"></line>
    <line x1="244" y1="440" x2="324" y2="440" class="solid"></line>
    <line x1="284" y1="440" x2="284" y2="472" class="solid"></line>
    <line x1="8" y1="472" x2="320" y2="472" class="solid"></line>
    <path d="M 324,468 A 4,4 0,0,1 320,472" class="nofill"></path>
  </g>
  <g>
    <path d="M 8,488 A 4,4 0,0,0 4,492" class="nofill"></path>
    <line x1="4" y1="492" x2="4" y2="580" class="solid"></line>
    <line x1="8" y1="488" x2="320" y2="488" class="solid"></line>
    <path d="M 320,488 A 4,4 0,0,1 324,492" class="nofill"></path>
    <line x1="324" y1="492" x2="324" y2="580" class="solid"></line>
    <path d="M 4,580 A 4,4 0,0,0 8,584" class="nofill"></path>
    <path d="M 168,504 A 4,4 0,0,0 164,508" class="nofill"></path>
    <line x1="164" y1="508" x2="164" y2="584" class="solid"></line>
    <line x1="168" y1="504" x2="324" y2="504" class="solid"></line>
    <path d="M 248,520 A 4,4 0,0,0 244,524" class="nofill"></path>
    <line x1="244" y1="524" x2="244" y2="584" class="solid"></line>
    <line x1="248" y1="520" x2="324" y2="520" class="solid"></line>
    <line x1="244" y1="552" x2="324" y2="552" class="solid"></line>
    <line x1="284" y1="552" x2="284" y2="584" class="solid"></line>
    <line x1="8" y1="584" x2="320" y2="584" class="solid"></line>
    <path d="M 324,580 A 4,4 0,0,1 320,584" class="nofill"></path>
  </g>
  <g>
    <path d="M 8,600 A 4,4 0,0,0 4,604" class="nofill"></path>
    <line x1="4" y1="604" x2="4" y2="692" class="solid"></line>
    <line x1="8" y1="600" x2="320" y2="600" class="solid"></line>
    <path d="M 320,600 A 4,4 0,0,1 324,604" class="nofill"></path>
    <line x1="324" y1="604" x2="324" y2="692" class="solid"></line>
    <path d="M 4,692 A 4,4 0,0,0 8,696" class="nofill"></path>
    <path d="M 168,616 A 4,4 0,0,0 164,620" class="nofill"></path>
    <line x1="164" y1="620" x2="164" y2="696" class="solid"></line>
    <line x1="168" y1="616" x2="324" y2="616" class="solid"></line>
    <path d="M 248,632 A 4,4 0,0,0 244,636" class="nofill"></path>
    <line x1="244" y1="636" x2="244" y2="696" class="solid"></line>
    <line x1="248" y1="632" x2="324" y2="632" class="solid"></line>
    <path d="M 288,664 A 4,4 0,0,0 284,668" class="nofill"></path>
    <line x1="284" y1="668" x2="284" y2="696" class="solid"></line>
    <line x1="288" y1="664" x2="324" y2="664" class="solid"></line>
    <line x1="8" y1="696" x2="320" y2="696" class="solid"></line>
    <path d="M 324,692 A 4,4 0,0,1 320,696" class="nofill"></path>
  </g>
  <g>
    <path d="M 8,712 A 4,4 0,0,0 4,716" class="nofill"></path>
    <line x1="4" y1="716" x2="4" y2="804" class="solid"></line>
    <line x1="8" y1="712" x2="320" y2="712" class="solid"></line>
    <path d="M 320,712 A 4,4 0,0,1 324,716" class="nofill"></path>
    <line x1="324" y1="716" x2="324" y2="804" class="solid"></line>
    <path d="M 4,804 A 4,4 0,0,0 8,808" class="nofill"></path>
    <path d="M 168,728 A 4,4 0,0,0 164,732" class="nofill"></path>
    <line x1="164" y1="732" x2="164" y2="808" class="solid"></line>
    <line x1="168" y1="728" x2="324" y2="728" class="solid"></line>
    <path d="M 248,744 A 4,4 0,0,0 244,748" class="nofill"></path>
    <line x1="244" y1="748" x2="244" y2="808" class="solid"></line>
    <line x1="248" y1="744" x2="324" y2="744" class="solid"></line>
    <path d="M 288,776 A 4,4 0,0,0 284,780" class="nofill"></path>
    <line x1="284" y1="780" x2="284" y2="808" class="solid"></line>
    <line x1="288" y1="776" x2="324" y2="776" class="solid"></line>
    <line x1="8" y1="808" x2="320" y2="808" class="solid"></line>
    <path d="M 324,804 A 4,4 0,0,1 320,808" class="nofill"></path>
  </g>
  <g>
    <path d="M 8,824 A 4,4 0,0,0 4,828" class="nofill"></path>
    <line x1="4" y1="828" x2="4" y2="916" class="solid"></line>
    <line x1="8" y1="824" x2="320" y2="824" class="solid"></line>
    <path d="M 320,824 A 4,4 0,0,1 324,828" class="nofill"></path>
    <line x1="324" y1="828" x2="324" y2="916" class="solid"></line>
    <path d="M 4,916 A 4,4 0,0,0 8,920" class="nofill"></path>
    <path d="M 168,840 A 4,4 0,0,0 164,844" class="nofill"></path>
    <line x1="164" y1="844" x2="164" y2="920" class="solid"></line>
    <line x1="168" y1="840" x2="324" y2="840" class="solid"></line>
    <path d="M 248,856 A 4,4 0,0,0 244,860" class="nofill"></path>
    <line x1="244" y1="860" x2="244" y2="920" class="solid"></line>
    <line x1="248" y1="856" x2="324" y2="856" class="solid"></line>
    <path d="M 288,888 A 4,4 0,0,0 284,892" class="nofill"></path>
    <line x1="284" y1="892" x2="284" y2="920" class="solid"></line>
    <line x1="288" y1="888" x2="324" y2="888" class="solid"></line>
    <line x1="8" y1="920" x2="320" y2="920" class="solid"></line>
    <path d="M 324,916 A 4,4 0,0,1 320,920" class="nofill"></path>
  </g>
  <g>
    <path d="M 8,936 A 4,4 0,0,0 4,940" class="nofill"></path>
    <line x1="4" y1="940" x2="4" y2="1028" class="solid"></line>
    <line x1="8" y1="936" x2="320" y2="936" class="solid"></line>
    <path d="M 320,936 A 4,4 0,0,1 324,940" class="nofill"></path>
    <line x1="324" y1="940" x2="324" y2="1028" class="solid"></line>
    <path d="M 4,1028 A 4,4 0,0,0 8,1032" class="nofill"></path>
    <path d="M 168,952 A 4,4 0,0,0 164,956" class="nofill"></path>
    <line x1="164" y1="956" x2="164" y2="1032" class="solid"></line>
    <line x1="168" y1="952" x2="324" y2="952" class="solid"></line>
    <path d="M 248,968 A 4,4 0,0,0 244,972" class="nofill"></path>
    <line x1="244" y1="972" x2="244" y2="1032" class="solid"></line>
    <line x1="248" y1="968" x2="324" y2="968" class="solid"></line>
    <path d="M 288,1000 A 4,4 0,0,0 284,1004" class="nofill"></path>
    <line x1="284" y1="1004" x2="284" y2="1032" class="solid"></line>
    <line x1="288" y1="1000" x2="324" y2="1000" class="solid"></line>
    <line x1="8" y1="1032" x2="320" y2="1032" class="solid"></line>
    <path d="M 324,1028 A 4,4 0,0,1 320,1032" class="nofill"></path>
  </g>
  <g>
    <path d="M 344,152 A 4,4 0,0,0 340,156" class="nofill"></path>
    <line x1="340" y1="156" x2="340" y2="244" class="solid"></line>
    <line x1="344" y1="152" x2="656" y2="152" class="solid"></line>
    <path d="M 656,152 A 4,4 0,0,1 660,156" class="nofill"></path>
    <line x1="660" y1="156" x2="660" y2="244" class="solid"></line>
    <path d="M 340,244 A 4,4 0,0,0 344,248" class="nofill"></path>
    <path d="M 504,168 A 4,4 0,0,0 500,172" class="nofill"></path>
    <line x1="500" y1="172" x2="500" y2="248" class="solid"></line>
    <line x1="504" y1="168" x2="660" y2="168" class="solid"></line>
    <path d="M 584,184 A 4,4 0,0,0 580,188" class="nofill"></path>
    <line x1="580" y1="188" x2="580" y2="248" class="solid"></line>
    <line x1="584" y1="184" x2="660" y2="184" class="solid"></line>
    <path d="M 624,216 A 4,4 0,0,0 620,220" class="nofill"></path>
    <line x1="620" y1="220" x2="620" y2="248" class="solid"></line>
    <line x1="624" y1="216" x2="660" y2="216" class="solid"></line>
    <line x1="344" y1="248" x2="656" y2="248" class="solid"></line>
    <path d="M 660,244 A 4,4 0,0,1 656,248" class="nofill"></path>
  </g>
  <g>
    <path d="M 344,264 A 4,4 0,0,0 340,268" class="nofill"></path>
    <line x1="340" y1="268" x2="340" y2="356" class="solid"></line>
    <line x1="344" y1="264" x2="656" y2="264" class="solid"></line>
    <path d="M 656,264 A 4,4 0,0,1 660,268" class="nofill"></path>
    <line x1="660" y1="268" x2="660" y2="356" class="solid"></line>
    <path d="M 340,356 A 4,4 0,0,0 344,360" class="nofill"></path>
    <path d="M 504,280 A 4,4 0,0,0 500,284" class="nofill"></path>
    <line x1="500" y1="284" x2="500" y2="360" class="solid"></line>
    <line x1="504" y1="280" x2="660" y2="280" class="solid"></line>
    <path d="M 584,296 A 4,4 0,0,0 580,300" class="nofill"></path>
    <line x1="580" y1="300" x2="580" y2="360" class="solid"></line>
    <line x1="584" y1="296" x2="660" y2="296" class="solid"></line>
    <path d="M 624,328 A 4,4 0,0,0 620,332" class="nofill"></path>
    <line x1="620" y1="332" x2="620" y2="360" class="solid"></line>
    <line x1="624" y1="328" x2="660" y2="328" class="solid"></line>
    <line x1="344" y1="360" x2="656" y2="360" class="solid"></line>
    <path d="M 660,356 A 4,4 0,0,1 656,360" class="nofill"></path>
  </g>
  <g>
    <path d="M 344,376 A 4,4 0,0,0 340,380" class="nofill"></path>
    <line x1="340" y1="380" x2="340" y2="468" class="solid"></line>
    <line x1="344" y1="376" x2="656" y2="376" class="solid"></line>
    <path d="M 656,376 A 4,4 0,0,1 660,380" class="nofill"></path>
    <line x1="660" y1="380" x2="660" y2="468" class="solid"></line>
    <path d="M 340,468 A 4,4 0,0,0 344,472" class="nofill"></path>
    <path d="M 504,392 A 4,4 0,0,0 500,396" class="nofill"></path>
    <line x1="500" y1="396" x2="500" y2="472" class="solid"></line>
    <line x1="504" y1="392" x2="660" y2="392" class="solid"></line>
    <path d="M 584,408 A 4,4 0,0,0 580,412" class="nofill"></path>
    <line x1="580" y1="412" x2="580" y2="472" class="solid"></line>
    <line x1="584" y1="408" x2="660" y2="408" class="solid"></line>
    <path d="M 624,440 A 4,4 0,0,0 620,444" class="nofill"></path>
    <line x1="620" y1="444" x2="620" y2="472" class="solid"></line>
    <line x1="624" y1="440" x2="660" y2="440" class="solid"></line>
    <line x1="344" y1="472" x2="656" y2="472" class="solid"></line>
    <path d="M 660,468 A 4,4 0,0,1 656,472" class="nofill"></path>
  </g>
  <g>
    <path d="M 344,488 A 4,4 0,0,0 340,492" class="nofill"></path>
    <line x1="340" y1="492" x2="340" y2="580" class="solid"></line>
    <line x1="344" y1="488" x2="656" y2="488" class="solid"></line>
    <path d="M 656,488 A 4,4 0,0,1 660,492" class="nofill"></path>
    <line x1="660" y1="492" x2="660" y2="580" class="solid"></line>
    <path d="M 340,580 A 4,4 0,0,0 344,584" class="nofill"></path>
    <path d="M 504,504 A 4,4 0,0,0 500,508" class="nofill"></path>
    <line x1="500" y1="508" x2="500" y2="584" class="solid"></line>
    <line x1="504" y1="504" x2="660" y2="504" class="solid"></line>
    <path d="M 584,520 A 4,4 0,0,0 580,524" class="nofill"></path>
    <line x1="580" y1="524" x2="580" y2="584" class="solid"></line>
    <line x1="584" y1="520" x2="660" y2="520" class="solid"></line>
    <path d="M 624,552 A 4,4 0,0,0 620,556" class="nofill"></path>
    <line x1="620" y1="556" x2="620" y2="584" class="solid"></line>
    <line x1="624" y1="552" x2="660" y2="552" class="solid"></line>
    <line x1="344" y1="584" x2="656" y2="584" class="solid"></line>
    <path d="M 660,580 A 4,4 0,0,1 656,584" class="nofill"></path>
  </g>
  <g>
    <path d="M 344,600 A 4,4 0,0,0 340,604" class="nofill"></path>
    <line x1="340" y1="604" x2="340" y2="692" class="solid"></line>
    <line x1="344" y1="600" x2="656" y2="600" class="solid"></line>
    <path d="M 656,600 A 4,4 0,0,1 660,604" class="nofill"></path>
    <line x1="660" y1="604" x2="660" y2="692" class="solid"></line>
    <path d="M 340,692 A 4,4 0,0,0 344,696" class="nofill"></path>
    <path d="M 504,616 A 4,4 0,0,0 500,620" class="nofill"></path>
    <line x1="500" y1="620" x2="500" y2="696" class="solid"></line>
    <line x1="504" y1="616" x2="660" y2="616" class="solid"></line>
    <path d="M 584,632 A 4,4 0,0,0 580,636" class="nofill"></path>
    <line x1="580" y1="636" x2="580" y2="696" class="solid"></line>
    <line x1="584" y1="632" x2="660" y2="632" class="solid"></line>
    <path d="M 624,664 A 4,4 0,0,0 620,668" class="nofill"></path>
    <line x1="620" y1="668" x2="620" y2="696" class="solid"></line>
    <line x1="624" y1="664" x2="660" y2="664" class="solid"></line>
    <line x1="344" y1="696" x2="656" y2="696" class="solid"></line>
    <path d="M 660,692 A 4,4 0,0,1 656,696" class="nofill"></path>
  </g>
  <g>
    <path d="M 344,712 A 4,4 0,0,0 340,716" class="nofill"></path>
    <line x1="340" y1="716" x2="340" y2="804" class="solid"></line>
    <line x1="344" y1="712" x2="656" y2="712" class="solid"></line>
    <path d="M 656,712 A 4,4 0,0,1 660,716" class="nofill"></path>
    <line x1="660" y1="716" x2="660" y2="804" class="solid"></line>
    <path d="M 340,804 A 4,4 0,0,0 344,808" class="nofill"></path>
    <path d="M 504,728 A 4,4 0,0,0 500,732" class="nofill"></path>
    <line x1="500" y1="732" x2="500" y2="808" class="solid"></line>
    <line x1="504" y1="728" x2="660" y2="728" class="solid"></line>
    <path d="M 584,744 A 4,4 0,0,0 580,748" class="nofill"></path>
    <line x1="580" y1="748" x2="580" y2="808" class="solid"></line>
    <line x1="584" y1="744" x2="660" y2="744" class="solid"></line>
    <path d="M 624,776 A 4,4 0,0,0 620,780" class="nofill"></path>
    <line x1="620" y1="780" x2="620" y2="808" class="solid"></line>
    <line x1="624" y1="776" x2="660" y2="776" class="solid"></line>
    <line x1="344" y1="808" x2="656" y2="808" class="solid"></line>
    <path d="M 660,804 A 4,4 0,0,1 656,808" class="nofill"></path>
  </g>
  <g>
    <path d="M 344,824 A 4,4 0,0,0 340,828" class="nofill"></path>
    <line x1="340" y1="828" x2="340" y2="916" class="solid"></line>
    <line x1="344" y1="824" x2="656" y2="824" class="solid"></line>
    <path d="M 656,824 A 4,4 0,0,1 660,828" class="nofill"></path>
    <line x1="660" y1="828" x2="660" y2="916" class="solid"></line>
    <path d="M 340,916 A 4,4 0,0,0 344,920" class="nofill"></path>
    <path d="M 504,840 A 4,4 0,0,0 500,844" class="nofill"></path>
    <line x1="500" y1="844" x2="500" y2="920" class="solid"></line>
    <line x1="504" y1="840" x2="660" y2="840" class="solid"></line>
    <path d="M 584,856 A 4,4 0,0,0 580,860" class="nofill"></path>
    <line x1="580" y1="860" x2="580" y2="920" class="solid"></line>
    <line x1="584" y1="856" x2="660" y2="856" class="solid"></line>
    <path d="M 624,888 A 4,4 0,0,0 620,892" class="nofill"></path>
    <line x1="620" y1="892" x2="620" y2="920" class="solid"></line>
    <line x1="624" y1="888" x2="660" y2="888" class="solid"></line>
    <line x1="344" y1="920" x2="656" y2="920" class="solid"></line>
    <path d="M 660,916 A 4,4 0,0,1 656,920" class="nofill"></path>
  </g>
  <g>
    <path d="M 344,936 A 4,4 0,0,0 340,940" class="nofill"></path>
    <line x1="340" y1="940" x2="340" y2="1028" class="solid"></line>
    <line x1="344" y1="936" x2="656" y2="936" class="solid"></line>
    <path d="M 656,936 A 4,4 0,0,1 660,940" class="nofill"></path>
    <line x1="660" y1="940" x2="660" y2="1028" class="solid"></line>
    <path d="M 340,1028 A 4,4 0,0,0 344,1032" class="nofill"></path>
    <path d="M 504,952 A 4,4 0,0,0 500,956" class="nofill"></path>
    <line x1="500" y1="956" x2="500" y2="1032" class="solid"></line>
    <line x1="504" y1="952" x2="660" y2="952" class="solid"></line>
    <path d="M 584,968 A 4,4 0,0,0 580,972" class="nofill"></path>
    <line x1="580" y1="972" x2="580" y2="1032" class="solid"></line>
    <line x1="584" y1="968" x2="660" y2="968" class="solid"></line>
    <path d="M 624,1000 A 4,4 0,0,0 620,1004" class="nofill"></path>
    <line x1="620" y1="1004" x2="620" y2="1032" class="solid"></line>
    <line x1="624" y1="1000" x2="660" y2="1000" class="solid"></line>
    <line x1="344" y1="1032" x2="656" y2="1032" class="solid"></line>
    <path d="M 660,1028 A 4,4 0,0,1 656,1032" class="nofill"></path>
  </g>
</svg></pre>
<h2 id="sse"><a class="header" href="#sse">SSE</a></h2>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">128-bit</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>xmm0</code></td></tr>
<tr><td style="text-align: center"><code>xmm1</code></td></tr>
<tr><td style="text-align: center"><code>xmm2</code></td></tr>
<tr><td style="text-align: center"><code>xmm3</code></td></tr>
<tr><td style="text-align: center"><code>xmm4</code></td></tr>
<tr><td style="text-align: center"><code>xmm5</code></td></tr>
<tr><td style="text-align: center"><code>xmm6</code></td></tr>
<tr><td style="text-align: center"><code>xmm7</code></td></tr>
<tr><td style="text-align: center"><code>xmm8</code></td></tr>
<tr><td style="text-align: center"><code>xmm9</code></td></tr>
<tr><td style="text-align: center"><code>xmm10</code></td></tr>
<tr><td style="text-align: center"><code>xmm11</code></td></tr>
<tr><td style="text-align: center"><code>xmm12</code></td></tr>
<tr><td style="text-align: center"><code>xmm13</code></td></tr>
<tr><td style="text-align: center"><code>xmm14</code></td></tr>
<tr><td style="text-align: center"><code>xmm15</code></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="flags"><a class="header" href="#flags">Flags</a></h1>
<ul>
<li><code>CF</code>: Carry flag<br />
Set if an arithmetic operation generates a carry or a borrow out of the most-significant bit of the result; cleared otherwise.<br />
This flag indicates an overflow condition for unsigned-integer arithmetic. It is also used in multiple-precision arithmetic.</li>
<li><code>PF</code>: Parity flag<br />
Set if the least-significant byte of the result contains an even number of 1 bits; cleared otherwise.</li>
<li><code>AF</code>: Auxiliary Carry flag/Adjust flag<br />
Set if an arithmetic operation generates a carry or a borrow out of bit 3 of the result; cleared otherwise.<br />
This flag is used in binary-coded decimal (BCD) arithmetic.</li>
<li><code>ZF</code>: Zero flag<br />
Set if the result is zero; cleared otherwise.</li>
<li><code>SF</code>: Sign flag<br />
Set equal to the most-significant bit of the result, which is the sign bit of a signed integer. (0 indicates a positive value and 1 indicates a negative value.)</li>
<li><code>OF</code>: Overflow flag<br />
Set if the integer result is too large a positive number or too small a negative number (excluding the sign-bit) to fit in the destination operand; cleared otherwise.<br />
This flag indicates an overflow condition for signed-integer (two’s complement) arithmetic.</li>
</ul>
<p>Of these status flags, only the <code>CF</code> flag can be modified directly, using the <code>STC</code>, <code>CLC</code>, and <code>CMC</code> instructions. Also the bit instructions (<code>BT</code>, <code>BTS</code>, <code>BTR</code>, and <code>BTC</code>) copy a specified bit into the <code>CF</code> flag.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="condition-codes"><a class="header" href="#condition-codes">Condition Codes</a></h1>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Condition Code</th><th style="text-align: left">Name</th><th style="text-align: left">Definition</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>e</code>, <code>z</code></td><td style="text-align: left">Equal, Zero</td><td style="text-align: left"><code>ZF == 1</code></td></tr>
<tr><td style="text-align: left"><code>ne</code>, <code>nz</code></td><td style="text-align: left">Not Equal, Not Zero</td><td style="text-align: left"><code>ZF == 0</code></td></tr>
<tr><td style="text-align: left"><code>o</code></td><td style="text-align: left">Overflow</td><td style="text-align: left"><code>OF == 1</code></td></tr>
<tr><td style="text-align: left"><code>no</code></td><td style="text-align: left">No Overflow</td><td style="text-align: left"><code>OF == 0</code></td></tr>
<tr><td style="text-align: left"><code>s</code></td><td style="text-align: left">Signed</td><td style="text-align: left"><code>SF == 1</code></td></tr>
<tr><td style="text-align: left"><code>ns</code></td><td style="text-align: left">Not Signed</td><td style="text-align: left"><code>SF == 0</code></td></tr>
<tr><td style="text-align: left"><code>p</code></td><td style="text-align: left">Parity</td><td style="text-align: left"><code>PF == 1</code></td></tr>
<tr><td style="text-align: left"><code>np</code></td><td style="text-align: left">No Parity</td><td style="text-align: left"><code>PF == 0</code></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>c</code>, <code>b</code>, <code>nae</code></td><td style="text-align: left">Carry, Below, Not Above or Equal</td><td style="text-align: left"><code>CF == 1</code></td></tr>
<tr><td style="text-align: left"><code>nc</code>, <code>nb</code>, <code>ae</code></td><td style="text-align: left">No Carry, Not Below, Above or Equal</td><td style="text-align: left"><code>CF == 0</code></td></tr>
<tr><td style="text-align: left"><code>a</code>, <code>nbe</code></td><td style="text-align: left">Above, Not Below or Equal</td><td style="text-align: left"><code>CF == 0</code> &amp; <code>ZF == 0</code></td></tr>
<tr><td style="text-align: left"><code>na</code>, <code>be</code></td><td style="text-align: left">Not Above, Below or Equal</td><td style="text-align: left"><code>CF == 1</code> | <code>ZF == 1</code></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>ge</code>, <code>nl</code></td><td style="text-align: left">Greater or Equal, Not Less</td><td style="text-align: left"><code>SF == OF</code></td></tr>
<tr><td style="text-align: left"><code>nge</code>, <code>l</code></td><td style="text-align: left">Not Greater or Equal, Less</td><td style="text-align: left"><code>SF != OF</code></td></tr>
<tr><td style="text-align: left"><code>g</code>, <code>nle</code></td><td style="text-align: left">Greater, Not Less or Equal</td><td style="text-align: left"><code>ZF == 0</code> &amp; <code>SF == OF</code></td></tr>
<tr><td style="text-align: left"><code>ng</code>, <code>le</code></td><td style="text-align: left">Not Greater, Less or Equal</td><td style="text-align: left"><code>ZF == 1</code> | <code>SF != OF</code></td></tr>
</tbody></table>
</div>
<p><sub>adapted from <a href="https://riptutorial.com/x86/example/6976/flags-register">https://riptutorial.com/x86/example/6976/flags-register</a></sub></p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="instructions"><a class="header" href="#instructions">Instructions</a></h1>
<h2 id="how-to-read-instructions"><a class="header" href="#how-to-read-instructions">How to read Instructions</a></h2>
<h3 id="operation"><a class="header" href="#operation">Operation</a></h3>
<ul>
<li><code>MSB</code>: Most Significant Bit</li>
<li><code>LSB</code>: Least Significant Bit</li>
</ul>
<p>The Syntax for the Operations closely follows the Rust syntax. Thus, Operators like <code>^</code> for Bitwise XOR, <code>&amp;</code> for Bitwise AND and <code>|</code> for Bitwise OR are used.</p>
<h2 id="instruction-set-summary"><a class="header" href="#instruction-set-summary">Instruction Set Summary</a></h2>
<h3 id="data-transfer-instructions"><a class="header" href="#data-transfer-instructions"><a href="instructions/data-transfer-instructions/README.html">Data Transfer Instructions</a></a></h3>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Mnemonic</th><th style="text-align: left">Summary</th></tr></thead><tbody>
<tr><td style="text-align: left"><a href="instructions/data-transfer-instructions/mov.html"><code>MOV</code></a></td><td style="text-align: left">Move</td></tr>
<tr><td style="text-align: left"><a href="instructions/data-transfer-instructions/xchg.html"><code>XCHG</code></a></td><td style="text-align: left">Exchange</td></tr>
<tr><td style="text-align: left"><a href="instructions/data-transfer-instructions/push.html"><code>PUSH</code></a></td><td style="text-align: left">Push Onto Stack</td></tr>
<tr><td style="text-align: left"><a href="instructions/data-transfer-instructions/pop.html"><code>POP</code></a></td><td style="text-align: left">Pop Off of Stack</td></tr>
</tbody></table>
</div>
<h3 id="binary-arithmetic-instructions"><a class="header" href="#binary-arithmetic-instructions"><a href="instructions/binary-arithmetic-instructions/README.html">Binary Arithmetic Instructions</a></a></h3>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Mnemonic</th><th style="text-align: left">Summary</th></tr></thead><tbody>
<tr><td style="text-align: left"><a href="instructions/binary-arithmetic-instructions/add.html"><code>ADD</code></a></td><td style="text-align: left">Integer Add</td></tr>
<tr><td style="text-align: left"><a href="instructions/binary-arithmetic-instructions/sub.html"><code>SUB</code></a></td><td style="text-align: left">Subtract</td></tr>
<tr><td style="text-align: left"><a href="instructions/binary-arithmetic-instructions/imul.html"><code>IMUL</code></a></td><td style="text-align: left">Signed Multiply</td></tr>
<tr><td style="text-align: left"><a href="instructions/binary-arithmetic-instructions/mul.html"><code>MUL</code></a></td><td style="text-align: left">Unsigned Multiply</td></tr>
<tr><td style="text-align: left"><a href="instructions/binary-arithmetic-instructions/idiv.html"><code>IDIV</code></a></td><td style="text-align: left">Signed Divide</td></tr>
<tr><td style="text-align: left"><a href="instructions/binary-arithmetic-instructions/div.html"><code>DIV</code></a></td><td style="text-align: left">Unsigned Divide</td></tr>
<tr><td style="text-align: left"><a href="instructions/binary-arithmetic-instructions/inc.html"><code>INC</code></a></td><td style="text-align: left">Increment</td></tr>
<tr><td style="text-align: left"><a href="instructions/binary-arithmetic-instructions/dec.html"><code>DEC</code></a></td><td style="text-align: left">Decrement</td></tr>
<tr><td style="text-align: left"><a href="instructions/binary-arithmetic-instructions/neg.html"><code>NEG</code></a></td><td style="text-align: left">Negate</td></tr>
<tr><td style="text-align: left"><a href="instructions/binary-arithmetic-instructions/cmp.html"><code>CMP</code></a></td><td style="text-align: left">Compare</td></tr>
</tbody></table>
</div>
<h3 id="logical-instructions"><a class="header" href="#logical-instructions"><a href="instructions/logical-instructions/README.html">Logical Instructions</a></a></h3>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Mnemonic</th><th style="text-align: left">Summary</th></tr></thead><tbody>
<tr><td style="text-align: left"><a href="instructions/logical-instructions/and.html"><code>AND</code></a></td><td style="text-align: left">Perform Bitwise Logical AND</td></tr>
<tr><td style="text-align: left"><a href="instructions/logical-instructions/or.html"><code>OR</code></a></td><td style="text-align: left">Perform Bitwise Logical OR</td></tr>
<tr><td style="text-align: left"><a href="instructions/logical-instructions/xor.html"><code>XOR</code></a></td><td style="text-align: left">Perform Bitwise Logical Exclusive OR</td></tr>
<tr><td style="text-align: left"><a href="instructions/logical-instructions/not.html"><code>NOT</code></a></td><td style="text-align: left">Perform Bitwise Logical NOT</td></tr>
</tbody></table>
</div>
<h3 id="shift-and-rotate-instructions"><a class="header" href="#shift-and-rotate-instructions"><a href="instructions/shift-and-rotate-instructions/README.html">Shift and Rotate Instructions</a></a></h3>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Mnemonic</th><th style="text-align: left">Summary</th></tr></thead><tbody>
<tr><td style="text-align: left"><a href="instructions/shift-and-rotate-instructions/sal,sar,shl,shr.html"><code>SAR</code></a></td><td style="text-align: left">Shift Arithmetic Right</td></tr>
<tr><td style="text-align: left"><a href="instructions/shift-and-rotate-instructions/sal,sar,shl,shr.html"><code>SHR</code></a></td><td style="text-align: left">Shift Logical Right</td></tr>
<tr><td style="text-align: left"><a href="instructions/shift-and-rotate-instructions/sal,sar,shl,shr.html"><code>SAL</code>|<code>SHL</code></a></td><td style="text-align: left">Shift Arithmetic Left/Shift Logical Left</td></tr>
</tbody></table>
</div>
<h3 id="bit-and-byte-instructions"><a class="header" href="#bit-and-byte-instructions"><a href="instructions/bit-and-byte-instructions/README.html">Bit and Byte Instructions</a></a></h3>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Mnemonic</th><th style="text-align: left">Summary</th></tr></thead><tbody>
<tr><td style="text-align: left"><a href="instructions/bit-and-byte-instructions/test.html"><code>TEST</code></a></td><td style="text-align: left">Logical Compare</td></tr>
</tbody></table>
</div>
<h3 id="control-transfer-instructions"><a class="header" href="#control-transfer-instructions"><a href="instructions/control-transfer-instructions/README.html">Control Transfer Instructions</a></a></h3>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Mnemonic</th><th style="text-align: left">Summary</th></tr></thead><tbody>
<tr><td style="text-align: left"><a href="instructions/control-transfer-instructions/jmp.html"><code>JMP</code></a></td><td style="text-align: left">Jump</td></tr>
<tr><td style="text-align: left"><a href="instructions/control-transfer-instructions/jcc.html"><code>Jcc</code></a></td><td style="text-align: left">Jump if <code>cc</code></td></tr>
<tr><td style="text-align: left"><a href="instructions/control-transfer-instructions/call.html"><code>CALL</code></a></td><td style="text-align: left">Call Procedure</td></tr>
<tr><td style="text-align: left"><a href="instructions/control-transfer-instructions/ret.html"><code>RET</code></a></td><td style="text-align: left">Return</td></tr>
</tbody></table>
</div>
<h3 id="miscellaneous-instructions"><a class="header" href="#miscellaneous-instructions"><a href="instructions/miscellaneous-instructions/README.html">Miscellaneous Instructions</a></a></h3>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Mnemonic</th><th style="text-align: left">Summary</th></tr></thead><tbody>
<tr><td style="text-align: left"><a href="instructions/miscellaneous-instructions/lea.html"><code>LEA</code></a></td><td style="text-align: left">Load Effective Address</td></tr>
<tr><td style="text-align: left"><a href="instructions/miscellaneous-instructions/nop.html"><code>NOP</code></a></td><td style="text-align: left">No Operation</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="data-transfer-instructions-1"><a class="header" href="#data-transfer-instructions-1">Data Transfer Instructions</a></h1>
<!-- ANCHOR: table -->
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Mnemonic</th><th style="text-align: left">Summary</th></tr></thead><tbody>
<tr><td style="text-align: left"><a href="instructions/data-transfer-instructions/mov.html"><code>MOV</code></a></td><td style="text-align: left">Move</td></tr>
<tr><td style="text-align: left"><a href="instructions/data-transfer-instructions/xchg.html"><code>XCHG</code></a></td><td style="text-align: left">Exchange</td></tr>
<tr><td style="text-align: left"><a href="instructions/data-transfer-instructions/push.html"><code>PUSH</code></a></td><td style="text-align: left">Push Onto Stack</td></tr>
<tr><td style="text-align: left"><a href="instructions/data-transfer-instructions/pop.html"><code>POP</code></a></td><td style="text-align: left">Pop Off of Stack</td></tr>
</tbody></table>
</div><!-- ANCHOR_END: table -->
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="mov"><a class="header" href="#mov"><code>MOV</code></a></h1>
<p>Move</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Instruction</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>MOV r/m8, r8</code></td><td style="text-align: left">Move <code>r8</code> to <code>r/m8</code></td></tr>
<tr><td style="text-align: left"><code>MOV r/m16, r16</code></td><td style="text-align: left">Move <code>r16</code> to <code>r/m16</code></td></tr>
<tr><td style="text-align: left"><code>MOV r/m32, r32</code></td><td style="text-align: left">Move <code>r32</code> to <code>r/m32</code></td></tr>
<tr><td style="text-align: left"><code>MOV r/m64, r64</code></td><td style="text-align: left">Move <code>r64</code> to <code>r/m64</code></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>MOV r8, r/m8</code></td><td style="text-align: left">Move <code>r/m8</code> to <code>r8</code></td></tr>
<tr><td style="text-align: left"><code>MOV r16, r/m16</code></td><td style="text-align: left">Move <code>r/m16</code> to <code>r16</code></td></tr>
<tr><td style="text-align: left"><code>MOV r32, r/m32</code></td><td style="text-align: left">Move <code>r/m32</code> to <code>r32</code></td></tr>
<tr><td style="text-align: left"><code>MOV r64, r/m64</code></td><td style="text-align: left">Move <code>r/m64</code> to <code>r64</code></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>MOV r/m8, imm8</code></td><td style="text-align: left">Move <code>imm8</code> to <code>r/m8</code></td></tr>
<tr><td style="text-align: left"><code>MOV r/m16, imm16</code></td><td style="text-align: left">Move <code>imm16</code> to <code>r/m16</code></td></tr>
<tr><td style="text-align: left"><code>MOV r/m32, imm32</code></td><td style="text-align: left">Move <code>imm32</code> to <code>r/m32</code></td></tr>
<tr><td style="text-align: left"><code>MOV r64, imm64</code></td><td style="text-align: left">Move <code>imm64</code> to <code>r64</code></td></tr>
<tr><td style="text-align: left"><code>MOV r/m64, imm32</code></td><td style="text-align: left">Move <code>imm32</code> sign-extended to <code>r/m64</code></td></tr>
</tbody></table>
</div>
<h2 id="description"><a class="header" href="#description">Description</a></h2>
<p>Copies the second operand (source operand) to the first operand (destination operand). The source operand can be an immediate value, general-purpose register, segment register, or memory location; the destination register can be a general-purpose register, segment register, or memory location. Both operands must be the same size, which can be a byte, a word, a doubleword, or a quadword.</p>
<p>The <code>MOV</code> instruction cannot be used to load the <code>CS</code> register. Attempting to do so results in an invalid opcode exception (#UD). To load the <code>CS</code> register, use the far <code>JMP</code>, <code>CALL</code>, or <code>RET</code> instruction.</p>
<p>If the destination operand is a segment register (<code>DS</code>, <code>ES</code>, <code>FS</code>, <code>GS</code>, or <code>SS</code>), the source operand must be a valid segment selector. In protected mode, moving a segment selector into a segment register automatically causes the segment descriptor information associated with that segment selector to be loaded into the hidden (shadow) part of the segment register. While loading this information, the segment selector and segment descriptor information is validated (see the <a href="instructions/data-transfer-instructions/mov.html#operation">Operation</a> algorithm below). The segment descriptor data is obtained from the <code>GDT</code> or <code>LDT</code> entry for the specified segment selector.</p>
<p>A <code>NULL</code> segment selector (values 0000-0003) can be loaded into the <code>DS</code>, <code>ES</code>, <code>FS</code>, and <code>GS</code> registers without causing a protection exception. However, any subsequent attempt to reference a segment whose corresponding segment register is loaded with a <code>NULL</code> value causes a general protection exception (#GP) and no memory reference occurs.</p>
<p>Loading the <code>SS</code> register with a <code>MOV</code> instruction suppresses or inhibits some debug exceptions and inhibits interrupts on the following instruction boundary. (The inhibition ends after delivery of an exception or the execution of the next instruction.) This behavior allows a stack pointer to be loaded into the <code>ESP</code> register with the next instruction (<code>MOV</code> <code>ESP</code>, stack-pointer value) before an event can be delivered. See Section 6.8.3, “Masking Exceptions and Interrupts When Switching Stacks,” in Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A. Intel recommends that software use the <code>LSS</code> instruction to load the <code>SS</code> register and <code>ESP</code> together.</p>
<p>When executing <code>MOV Reg, Sreg</code>, the processor copies the content of <code>Sreg</code> to the 16 least significant bits of the general-purpose register. The upper bits of the destination register are zero for most IA-32 processors (Pentium Pro processors and later) and all Intel 64 processors, with the exception that bits 31:16 are undefined for Intel Quark X1000 processors, Pentium and earlier processors.</p>
<p>In 64-bit mode, the instruction’s default operation size is 32 bits. Use of the <code>REX.R</code> prefix permits access to additional registers (<code>R8</code>-<code>R15</code>). Use of the <code>REX.W</code> prefix promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.</p>
<h2 id="operation-1"><a class="header" href="#operation-1">Operation</a></h2>
<p><code>DEST</code>: first operand<br />
<code>SRC</code>: second operand</p>
<pre><code class="language-rust ignore">DEST = SRC;
</code></pre>
<h2 id="flags-affected"><a class="header" href="#flags-affected">Flags Affected</a></h2>
<p>None.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="xchg"><a class="header" href="#xchg"><code>XCHG</code></a></h1>
<p>Exchange Register/Memory with Register</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Instruction</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>XCHG r/m8, r8</code></td><td style="text-align: left">Exchange <code>r/m8</code> with <code>r8</code></td></tr>
<tr><td style="text-align: left"><code>XCHG r/m16 r16</code></td><td style="text-align: left">Exchange <code>r/m16</code> with <code>r16</code></td></tr>
<tr><td style="text-align: left"><code>XCHG r/m32 r32</code></td><td style="text-align: left">Exchange <code>r/m32</code> with <code>r32</code></td></tr>
<tr><td style="text-align: left"><code>XCHG r/m64 r64</code></td><td style="text-align: left">Exchange <code>r/m64</code> with <code>r64</code></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>XCHG r8, r/m8</code></td><td style="text-align: left">Exchange <code>r8</code> with <code>r/m8</code></td></tr>
<tr><td style="text-align: left"><code>XCHG r16, r/m16</code></td><td style="text-align: left">Exchange <code>r16</code> with <code>r/m16</code></td></tr>
<tr><td style="text-align: left"><code>XCHG r32, r/m32</code></td><td style="text-align: left">Exchange <code>r32</code> with <code>r/m32</code></td></tr>
<tr><td style="text-align: left"><code>XCHG r64, r/m64</code></td><td style="text-align: left">Exchange <code>r64</code> with <code>r/m64</code></td></tr>
</tbody></table>
</div>
<h2 id="description-1"><a class="header" href="#description-1">Description</a></h2>
<p>Exchanges the contents of the destination (first) and source (second) operands. The operands can be two general-purpose registers or a register and a memory location. If a memory operand is referenced, the processor’s locking protocol is automatically implemented for the duration of the exchange operation, regardless of the presence or absence of the <code>LOCK</code> prefix or of the value of the <code>IOPL</code>. (See the <code>LOCK</code> prefix description in this chapter for more information on the locking protocol.)</p>
<p>This instruction is useful for implementing semaphores or similar data structures for process synchronization. (See “Bus Locking” in Chapter 8 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A, for more information on bus locking.)</p>
<p>The <code>XCHG</code> instruction can also be used instead of the <code>BSWAP</code> instruction for 16-bit operands.</p>
<p>In 64-bit mode, the instruction’s default operation size is 32 bits. Using a <code>REX</code> prefix in the form of <code>REX.R</code> permits access to additional registers (<code>R8</code>-<code>R15</code>). Using a <code>REX</code> prefix in the form of <code>REX.W</code> promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.</p>
<blockquote>
<p><code>XCHG (E)AX, (E)AX</code> (encoded instruction byte is 90H) is an alias for <code>NOP</code> regardless of data size prefixes, including <code>REX.W</code>.</p>
</blockquote>
<h2 id="operation-2"><a class="header" href="#operation-2">Operation</a></h2>
<p><code>DEST</code>: first operand<br />
<code>SRC</code>: second operand</p>
<pre><code class="language-rust ignore">TEMP = DEST;
DEST = SRC;
SRC = TEMP;
</code></pre>
<h2 id="flags-affected-1"><a class="header" href="#flags-affected-1">Flags Affected</a></h2>
<p>None.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="push"><a class="header" href="#push"><code>PUSH</code></a></h1>
<p>Push Word, Doubleword or Quadword Onto the Stack</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Instruction</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>PUSH r/m16</code></td><td style="text-align: left">Push <code>r/m16</code></td></tr>
<tr><td style="text-align: left"><code>PUSH r/m32</code></td><td style="text-align: left">Push <code>r/m32</code></td></tr>
<tr><td style="text-align: left"><code>PUSH r/m64</code></td><td style="text-align: left">Push <code>r/m64</code></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>PUSH r16</code></td><td style="text-align: left">Push <code>r16</code></td></tr>
<tr><td style="text-align: left"><code>PUSH r32</code></td><td style="text-align: left">Push <code>r32</code></td></tr>
<tr><td style="text-align: left"><code>PUSH r64</code></td><td style="text-align: left">Push <code>r64</code></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>PUSH imm8</code></td><td style="text-align: left">Push <code>imm8</code></td></tr>
<tr><td style="text-align: left"><code>PUSH imm16</code></td><td style="text-align: left">Push <code>imm16</code></td></tr>
<tr><td style="text-align: left"><code>PUSH imm32</code></td><td style="text-align: left">Push <code>imm32</code></td></tr>
</tbody></table>
</div>
<h2 id="description-2"><a class="header" href="#description-2">Description</a></h2>
<p>Decrements the stack pointer and then stores the source operand on the top of the stack. Address and operand sizes are determined and used as follows:</p>
<ul>
<li>
<p>Address size. The <code>D</code> flag in the current code-segment descriptor determines the default address size; it may be overridden by an instruction prefix (<code>0x67</code>).<br />
The address size is used only when referencing a source operand in memory.</p>
</li>
<li>
<p>Operand size. The <code>D</code> flag in the current code-segment descriptor determines the default operand size; it may be overridden by instruction prefixes (<code>0x66</code> or <code>REX.W</code>).</p>
<p>The operand size (16, 32, or 64 bits) determines the amount by which the stack pointer is decremented (2, 4 or 8).</p>
<p>If the source operand is an immediate of size less than the operand size, a sign-extended value is pushed on the stack. If the source operand is a segment register (16 bits) and the operand size is 64-bits, a zero-extended value is pushed on the stack; if the operand size is 32-bits, either a zero-extended value is pushed on the stack or the segment selector is written on the stack using a 16-bit move. For the last case, all recent Core and Atom processors perform a 16-bit move, leaving the upper portion of the stack location unmodified.</p>
</li>
<li>
<p>Stack-address size. Outside of 64-bit mode, the B flag in the current stack-segment descriptor determines the size of the stack pointer (16 or 32 bits); in 64-bit mode, the size of the stack pointer is always 64 bits.</p>
<p>The stack-address size determines the width of the stack pointer when writing to the stack in memory and when decrementing the stack pointer. (As stated above, the amount by which the stack pointer is decremented is determined by the operand size.)</p>
<p>If the operand size is less than the stack-address size, the <code>PUSH</code> instruction may result in a misaligned stack pointer (a stack pointer that is not aligned on a doubleword or quadword boundary).
The <code>PUSH ESP</code> instruction pushes the value of the <code>ESP</code> register as it existed before the instruction was executed. If a <code>PUSH</code> instruction uses a memory operand in which the <code>ESP</code> register is used for computing the operand address, the address of the operand is computed before the <code>ESP</code> register is decremented.</p>
</li>
</ul>
<p>If the <code>ESP</code> or <code>SP</code> register is 1 when the <code>PUSH</code> instruction is executed in real-address mode, a stack-fault exception (<code>#SS</code>) is generated (because the limit of the stack segment is violated). Its delivery encounters a second stackfault exception (for the same reason), causing generation of a double-fault exception (<code>#DF</code>). Delivery of the double-fault exception encounters a third stack-fault exception, and the logical processor enters shutdown mode. See the discussion of the double-fault exception in Chapter 6 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A.</p>
<h2 id="operation-3"><a class="header" href="#operation-3">Operation</a></h2>
<p>See Description section for possible sign-extension or zero-extension of source operand and for a case in which the size of the memory store may be smaller than the instruction’s operand size</p>
<p><code>SRC</code>: operand</p>
<h3 id="operandsize--16"><a class="header" href="#operandsize--16">OperandSize = 16</a></h3>
<pre><code class="language-rust ignore">// push word
RSP = RSP - 2;
Memory[SS:RSP] = SRC;
</code></pre>
<h3 id="operandsize--32"><a class="header" href="#operandsize--32">OperandSize = 32</a></h3>
<pre><code class="language-rust ignore">// push dword
RSP = RSP - 4;
Memory[SS:RSP] = SRC;
</code></pre>
<h3 id="operandsize--64"><a class="header" href="#operandsize--64">OperandSize = 64</a></h3>
<pre><code class="language-rust ignore">// push quadword
RSP = RPS - 8;
Memory[SS:RSP] = SRC;
</code></pre>
<h2 id="flags-affected-2"><a class="header" href="#flags-affected-2">Flags Affected</a></h2>
<p>None.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="pop"><a class="header" href="#pop"><code>POP</code></a></h1>
<p>Pop a Value from the Stack</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Instruction</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>POP r/m16</code></td><td style="text-align: left">Pop top of stack into <code>r/m16</code>; increment stack pointer</td></tr>
<tr><td style="text-align: left"><code>POP r/m32</code></td><td style="text-align: left">Pop top of stack into <code>r/m32</code>; increment stack pointer</td></tr>
<tr><td style="text-align: left"><code>POP r/m64</code></td><td style="text-align: left">Pop top of stack into <code>r/m64</code>; increment stack pointer</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>POP r16</code></td><td style="text-align: left">Pop top of stack into <code>r16</code>; increment stack pointer</td></tr>
<tr><td style="text-align: left"><code>POP r32</code></td><td style="text-align: left">Pop top of stack into <code>r32</code>; increment stack pointer</td></tr>
<tr><td style="text-align: left"><code>POP r64</code></td><td style="text-align: left">Pop top of stack into <code>r64</code>; increment stack pointer</td></tr>
</tbody></table>
</div>
<h2 id="description-3"><a class="header" href="#description-3">Description</a></h2>
<p>Loads the value from the top of the stack to the location specified with the destination operand (or explicit opcode) and then increments the stack pointer. The destination operand can be a general-purpose register, memory location, or segment register.</p>
<p>Address and operand sizes are determined and used as follows:</p>
<ul>
<li>
<p>Address size. The <code>D</code> flag in the current code-segment descriptor determines the default address size; it may be overridden by an instruction prefix (<code>0x67</code>).</p>
<p>The address size is used only when writing to a destination operand in memory.</p>
</li>
<li>
<p>Operand size. The <code>D</code> flag in the current code-segment descriptor determines the default operand size; it may be overridden by instruction prefixes (<code>0x66</code> or <code>REX.W</code>).</p>
<p>The operand size (16, 32, or 64 bits) determines the amount by which the stack pointer is incremented (2, 4 or 8).</p>
</li>
<li>
<p>Stack-address size. Outside of 64-bit mode, the B flag in the current stack-segment descriptor determines the size of the stack pointer (16 or 32 bits); in 64-bit mode, the size of the stack pointer is always 64 bits.</p>
<p>The stack-address size determines the width of the stack pointer when reading from the stack in memory and when incrementing the stack pointer. (As stated above, the amount by which the stack pointer is incremented is determined by the operand size.)
If the destination operand is one of the segment registers <code>DS</code>, <code>ES</code>, <code>FS</code>, <code>GS</code>, or <code>SS</code>, the value loaded into the register must be a valid segment selector. In protected mode, popping a segment selector into a segment register automatically causes the descriptor information associated with that segment selector to be loaded into the hidden (shadow) part of the segment register and causes the selector and the descriptor information to be validated (see the <a href="instructions/data-transfer-instructions/pop.html#operation">Operation section</a> below).</p>
</li>
</ul>
<p>A <code>NULL</code> value (0000-0003) may be popped into the <code>DS</code>, <code>ES</code>, <code>FS</code>, or <code>GS</code> register without causing a general protection fault. However, any subsequent attempt to reference a segment whose corresponding segment register is loaded with a <code>NULL</code> value causes a general protection exception (<code>#GP</code>). In this situation, no memory reference occurs and the saved value of the segment register is <code>NULL</code>.</p>
<p>The <code>POP</code> instruction cannot pop a value into the <code>CS</code> register. To load the <code>CS</code> register from the stack, use the <code>RET</code> instruction.</p>
<p>If the <code>ESP</code> register is used as a base register for addressing a destination operand in memory, the <code>POP</code> instruction computes the effective address of the operand after it increments the <code>ESP</code> register. For the case of a 16-bit stack where <code>ESP</code> wraps to <code>0x0</code> as a result of the <code>POP</code> instruction, the resulting location of the memory write is processor-family-specific.</p>
<p>The <code>POP ESP</code> instruction increments the stack pointer (<code>ESP</code>) before data at the old top of stack is written into the destination.</p>
<p>Loading the <code>SS</code> register with a <code>POP</code> instruction suppresses or inhibits some debug exceptions and inhibits interrupts on the following instruction boundary. (The inhibition ends after delivery of an exception or the execution of the next instruction.) This behavior allows a stack pointer to be loaded into the <code>ESP</code> register with the next instruction (<code>POP ESP</code>) before an event can be delivered. See Section 6.8.3, “Masking Exceptions and Interrupts When Switching Stacks,” in Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A. Intel recommends that software use the LSS instruction to load the <code>SS</code> register and <code>ESP</code> together.</p>
<p>In 64-bit mode, using a <code>REX</code> prefix in the form of <code>REX.R</code> permits access to additional registers (<code>R8</code>-<code>R15</code>). When in 64-bit mode, <code>POP</code>s using 32-bit operands are not encodable and <code>POP</code>s to <code>DS</code>, <code>ES</code>, <code>SS</code> are not valid. See the summary chart at the beginning of this section for encoding data and limits.</p>
<h2 id="operation-4"><a class="header" href="#operation-4">Operation</a></h2>
<p><code>DEST</code>: operand</p>
<h3 id="operandsize--16-1"><a class="header" href="#operandsize--16-1">OperandSize = 16</a></h3>
<pre><code class="language-rust ignore">DEST = SS:RSP;
RSP = RSP + 2;
</code></pre>
<h3 id="operandsize--32-1"><a class="header" href="#operandsize--32-1">OperandSize = 32</a></h3>
<pre><code class="language-rust ignore">DEST = SS:RSP;
RSP = RSP + 4;
</code></pre>
<h3 id="operandsize--64-1"><a class="header" href="#operandsize--64-1">OperandSize = 64</a></h3>
<pre><code class="language-rust ignore">DEST = SS:RSP;
RSP = RSP + 8;
</code></pre>
<h2 id="flags-affected-3"><a class="header" href="#flags-affected-3">Flags Affected</a></h2>
<p>None.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="binary-arithmetic-instructions-1"><a class="header" href="#binary-arithmetic-instructions-1">Binary Arithmetic Instructions</a></h1>
<!-- ANCHOR: table -->
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Mnemonic</th><th style="text-align: left">Summary</th></tr></thead><tbody>
<tr><td style="text-align: left"><a href="instructions/binary-arithmetic-instructions/add.html"><code>ADD</code></a></td><td style="text-align: left">Integer Add</td></tr>
<tr><td style="text-align: left"><a href="instructions/binary-arithmetic-instructions/sub.html"><code>SUB</code></a></td><td style="text-align: left">Subtract</td></tr>
<tr><td style="text-align: left"><a href="instructions/binary-arithmetic-instructions/imul.html"><code>IMUL</code></a></td><td style="text-align: left">Signed Multiply</td></tr>
<tr><td style="text-align: left"><a href="instructions/binary-arithmetic-instructions/mul.html"><code>MUL</code></a></td><td style="text-align: left">Unsigned Multiply</td></tr>
<tr><td style="text-align: left"><a href="instructions/binary-arithmetic-instructions/idiv.html"><code>IDIV</code></a></td><td style="text-align: left">Signed Divide</td></tr>
<tr><td style="text-align: left"><a href="instructions/binary-arithmetic-instructions/div.html"><code>DIV</code></a></td><td style="text-align: left">Unsigned Divide</td></tr>
<tr><td style="text-align: left"><a href="instructions/binary-arithmetic-instructions/inc.html"><code>INC</code></a></td><td style="text-align: left">Increment</td></tr>
<tr><td style="text-align: left"><a href="instructions/binary-arithmetic-instructions/dec.html"><code>DEC</code></a></td><td style="text-align: left">Decrement</td></tr>
<tr><td style="text-align: left"><a href="instructions/binary-arithmetic-instructions/neg.html"><code>NEG</code></a></td><td style="text-align: left">Negate</td></tr>
<tr><td style="text-align: left"><a href="instructions/binary-arithmetic-instructions/cmp.html"><code>CMP</code></a></td><td style="text-align: left">Compare</td></tr>
</tbody></table>
</div><!-- ANCHOR_END: table -->
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="add"><a class="header" href="#add"><code>ADD</code></a></h1>
<p>Add</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Instruction</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>ADD r/m8, imm8</code></td><td style="text-align: left">Add <code>imm8</code> to <code>r/m8</code></td></tr>
<tr><td style="text-align: left"><code>ADD r/m16, imm16</code></td><td style="text-align: left">Add <code>imm16</code> to <code>r/m16</code></td></tr>
<tr><td style="text-align: left"><code>ADD r/m32, imm32</code></td><td style="text-align: left">Add <code>imm32</code> to <code>r/m32</code></td></tr>
<tr><td style="text-align: left"><code>ADD r/m64, imm32</code></td><td style="text-align: left">Add sign-extended <code>imm32</code> to <code>r/m64</code></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>ADD r/m16, imm8</code></td><td style="text-align: left">Add sign-extended <code>imm8</code> to <code>r/m16</code></td></tr>
<tr><td style="text-align: left"><code>ADD r/m32, imm8</code></td><td style="text-align: left">Add sign-extended <code>imm8</code> to <code>r/m32</code></td></tr>
<tr><td style="text-align: left"><code>ADD r/m64, imm8</code></td><td style="text-align: left">Add sign-extended <code>imm8</code> to <code>r/m64</code></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>ADD r/m8, r8</code></td><td style="text-align: left">Add <code>r8</code> to <code>r/m8</code></td></tr>
<tr><td style="text-align: left"><code>ADD r/m16, r16</code></td><td style="text-align: left">Add <code>r16</code> to <code>r/m16</code></td></tr>
<tr><td style="text-align: left"><code>ADD r/m32, r32</code></td><td style="text-align: left">Add <code>r32</code> to <code>r/m32</code></td></tr>
<tr><td style="text-align: left"><code>ADD r/m64, r64</code></td><td style="text-align: left">Add <code>r64</code> to <code>r/m64</code></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>ADD r8, r/m8</code></td><td style="text-align: left">ADD <code>r/m8</code> to <code>r8</code></td></tr>
<tr><td style="text-align: left"><code>ADD r16, r/m16</code></td><td style="text-align: left">ADD <code>r/m16</code> to <code>r16</code></td></tr>
<tr><td style="text-align: left"><code>ADD r32, r/m32</code></td><td style="text-align: left">ADD <code>r/m32</code> to <code>r32</code></td></tr>
<tr><td style="text-align: left"><code>ADD r64, r/m64</code></td><td style="text-align: left">ADD <code>r/m64</code> to <code>r64</code></td></tr>
</tbody></table>
</div>
<h2 id="description-4"><a class="header" href="#description-4">Description</a></h2>
<p>Adds the destination operand (first operand) and the source operand (second operand) and then stores the result in the destination operand. The destination operand can be a register or a memory location; the source operand can be an immediate, a register, or a memory location. (However, two memory operands cannot be used in one instruction.) When an immediate value is used as an operand, it is sign-extended to the length of the destination operand format.</p>
<p>The <code>ADD</code> instruction performs integer addition. It evaluates the result for both signed and unsigned integer operands and sets the <code>OF</code> and <code>CF</code> flags to indicate a carry (overflow) in the signed or unsigned result, respectively. The <code>SF</code> flag indicates the sign of the signed result.</p>
<p>This instruction can be used with a <code>LOCK</code> prefix to allow the instruction to be executed atomically.</p>
<h2 id="operation-5"><a class="header" href="#operation-5">Operation</a></h2>
<p><code>DEST</code>: first operand<br />
<code>SRC</code>: second operand</p>
<pre><code class="language-rust ignore">DEST = DEST + SRC;
</code></pre>
<h2 id="flags-affected-4"><a class="header" href="#flags-affected-4">Flags Affected</a></h2>
<p><code>OF</code>, <code>SF</code>, <code>ZF</code>, <code>AF</code>, <code>CF</code>, <code>PF</code></p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="sub"><a class="header" href="#sub"><code>SUB</code></a></h1>
<p>Subtract</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Instruction</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>SUB r/m8, imm8</code></td><td style="text-align: left">Subtract <code>imm8</code> from <code>r/m8</code></td></tr>
<tr><td style="text-align: left"><code>SUB r/m16, imm16</code></td><td style="text-align: left">Subtract <code>imm16</code> from <code>r/m16</code></td></tr>
<tr><td style="text-align: left"><code>SUB r/m32, imm32</code></td><td style="text-align: left">Subtract <code>imm32</code> from <code>r/m32</code></td></tr>
<tr><td style="text-align: left"><code>SUB r/m64, imm32</code></td><td style="text-align: left">Subtract sign-extended <code>imm32</code> from <code>r/m64</code></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>SUB r/m16, imm8</code></td><td style="text-align: left">Subtract sign-extended <code>imm8</code> from <code>r/m16</code></td></tr>
<tr><td style="text-align: left"><code>SUB r/m32, imm8</code></td><td style="text-align: left">Subtract sign-extended <code>imm8</code> from <code>r/m32</code></td></tr>
<tr><td style="text-align: left"><code>SUB r/m64, imm8</code></td><td style="text-align: left">Subtract sign-extended <code>imm8</code> from <code>r/m64</code></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>SUB r/m8, r8</code></td><td style="text-align: left">Subtract <code>r8</code> from <code>r/m8</code></td></tr>
<tr><td style="text-align: left"><code>SUB r/m16, r16</code></td><td style="text-align: left">Subtract <code>r16</code> from <code>r/m16</code></td></tr>
<tr><td style="text-align: left"><code>SUB r/m32, r32</code></td><td style="text-align: left">Subtract <code>r32</code> from <code>r/m32</code></td></tr>
<tr><td style="text-align: left"><code>SUB r/m64, r64</code></td><td style="text-align: left">Subtract <code>r64</code> from <code>r/m64</code></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>SUB r8, r/m8</code></td><td style="text-align: left">Subtract <code>r/m8</code> from <code>r8</code></td></tr>
<tr><td style="text-align: left"><code>SUB r16, r/m16</code></td><td style="text-align: left">Subtract <code>r/m16</code> from <code>r16</code></td></tr>
<tr><td style="text-align: left"><code>SUB r32, r/m32</code></td><td style="text-align: left">Subtract <code>r/m32</code> from <code>r32</code></td></tr>
<tr><td style="text-align: left"><code>SUB r64, r/m64</code></td><td style="text-align: left">Subtract <code>r/m64</code> from <code>r64</code></td></tr>
</tbody></table>
</div>
<h2 id="description-5"><a class="header" href="#description-5">Description</a></h2>
<p>Subtracts the second operand (source operand) from the first operand (destination operand) and stores the result in the destination operand. The destination operand can be a register or a memory location; the source operand can be an immediate, register, or memory location. (However, two memory operands cannot be used in one instruction.) When an immediate value is used as an operand, it is sign-extended to the length of the destination operand format.</p>
<p>The <code>SUB</code> instruction performs integer subtraction. It evaluates the result for both signed and unsigned integer operands and sets the <code>OF</code> and <code>CF</code> flags to indicate an overflow in the signed or unsigned result, respectively. The <code>SF</code> flag indicates the sign of the signed result.</p>
<p>This instruction can be used with a <code>LOCK</code> prefix to allow the instruction to be executed atomically.</p>
<h2 id="operation-6"><a class="header" href="#operation-6">Operation</a></h2>
<p><code>DEST</code>: first operand<br />
<code>SRC</code>: second operand</p>
<pre><code class="language-rust ignore">DEST = DEST – SRC;
</code></pre>
<h2 id="flags-affected-5"><a class="header" href="#flags-affected-5">Flags Affected</a></h2>
<p><code>OF</code>, <code>SF</code>, <code>ZF</code>, <code>AF</code>, <code>PF</code>, <code>CF</code></p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="imul"><a class="header" href="#imul"><code>IMUL</code></a></h1>
<p>Signed Multiply</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Instruction</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>IMUL r/m8</code></td><td style="text-align: left"><code>AX = AL * r/m8</code></td></tr>
<tr><td style="text-align: left"><code>IMUL r/m16</code></td><td style="text-align: left"><code>DX:AX = AX * r/m16</code></td></tr>
<tr><td style="text-align: left"><code>IMUL r/m32</code></td><td style="text-align: left"><code>EDX:EAX = EAX * r/m32</code></td></tr>
<tr><td style="text-align: left"><code>IMUL r/m64</code></td><td style="text-align: left"><code>RDX:RAX = RAX * r/m64</code></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>IMUL r16, r/m16</code></td><td style="text-align: left"><code>r16 = r16 * r/m16</code></td></tr>
<tr><td style="text-align: left"><code>IMUL r32, r/m32</code></td><td style="text-align: left"><code>r32 = r32 * r/m32</code></td></tr>
<tr><td style="text-align: left"><code>IMUL r64, r/m64</code></td><td style="text-align: left"><code>r64 = r64 * r/m64</code></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>IMUL r16, r/m16, imm16</code>*</td><td style="text-align: left"><code>r16 = r/m16 * imm16</code></td></tr>
<tr><td style="text-align: left"><code>IMUL r32, r/m32, imm32</code>*</td><td style="text-align: left"><code>r32 = r/m32 * imm32</code></td></tr>
<tr><td style="text-align: left"><code>IMUL r64, r/m64, imm32</code>*</td><td style="text-align: left"><code>r64 = r/m64 * imm32</code></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>IMUL r16, r/m16, imm8</code>*</td><td style="text-align: left"><code>r16 = r/m16 *</code> sign-extended <code>imm8</code></td></tr>
<tr><td style="text-align: left"><code>IMUL r32, r/m32, imm8</code>*</td><td style="text-align: left"><code>r32 = r/m32 *</code> sign-extended <code>imm8</code></td></tr>
<tr><td style="text-align: left"><code>IMUL r64, r/m64, imm8</code>*</td><td style="text-align: left"><code>r64 = r/m64 *</code> sign-extended <code>imm8</code></td></tr>
</tbody></table>
</div>
<p>* If the first two operands are the same, the second one can be left out when using <code>nasm</code> or <code>.intel_syntax noprefix</code>.</p>
<h2 id="description-6"><a class="header" href="#description-6">Description</a></h2>
<p>Performs a signed multiplication of two operands. This instruction has three forms, depending on the number of operands.</p>
<ul>
<li><strong>One-operand form</strong><br />
This form is identical to that used by the <code>MUL</code> instruction. Here, the source operand (in a general-purpose register or memory location) is multiplied by the value in the <code>AL</code>, <code>AX</code>, <code>EAX</code>, or <code>RAX</code> register (depending on the operand size) and the product (twice the size of the input operand) is stored in the <code>AX</code>, <code>DX:AX</code>, <code>EDX:EAX</code>, or <code>RDX:RAX</code> registers, respectively.</li>
<li><strong>Two-operand form</strong><br />
With this form the destination operand (the first operand) is multiplied by the source operand (second operand). The destination operand is a general-purpose register and the source operand is an immediate value, a general-purpose register, or a memory location. The intermediate product (twice the size of the input operand) is truncated and stored in the destination operand location.</li>
<li><strong>Three-operand form</strong><br />
This form requires a destination operand (the first operand) and two source operands (the second and the third operands). Here, the first source operand (which can be a general-purpose register or a memory location) is multiplied by the second source operand (an immediate value). The intermediate product (twice the size of the first source operand) is truncated and stored in the destination operand (a general-purpose register).
When an immediate value is used as an operand, it is sign-extended to the length of the destination operand format.</li>
</ul>
<p>The <code>CF</code> and <code>OF</code> flags are set when the signed integer value of the intermediate product differs from the sign-extended operand-size-truncated product, otherwise the <code>CF</code> and <code>OF</code> flags are cleared.</p>
<p>The three forms of the <code>IMUL</code> instruction are similar in that the length of the product is calculated to twice the length of the operands. With the one-operand form, the product is stored exactly in the destination. With the two- and three- operand forms, however, the result is truncated to the length of the destination before it is stored in the destination register. Because of this truncation, the <code>CF</code> or <code>OF</code> flag should be tested to ensure that no significant bits are lost.</p>
<p>The two- and three-operand forms may also be used with unsigned operands because the lower half of the product is the same regardless if the operands are signed or unsigned. The <code>CF</code> and <code>OF</code> flags, however, cannot be used to determine if the upper half of the result is non-zero.</p>
<p>In 64-bit mode, the instruction’s default operation size is 32 bits. Use of the <code>REX.R</code> prefix permits access to additional registers (<code>R8</code>-<code>R15</code>). Use of the <code>REX.W</code> prefix promotes operation to 64 bits. Use of <code>REX.W</code> modifies the three forms of the instruction as follows.</p>
<ul>
<li><strong>One-operand form</strong><br />
The source operand (in a 64-bit general-purpose register or memory location) is multiplied by the value in the <code>RAX</code> register and the product is stored in the <code>RDX:RAX</code> registers.</li>
<li><strong>Two-operand form</strong><br />
The source operand is promoted to 64 bits if it is a register or a memory location. The destination operand is promoted to 64 bits.</li>
<li><strong>Three-operand form</strong><br />
The first source operand (either a register or a memory location) and destination operand are promoted to 64 bits. If the source operand is an immediate, it is sign-extended to 64 bits.</li>
</ul>
<h2 id="operation-7"><a class="header" href="#operation-7">Operation</a></h2>
<h3 id="single-operand"><a class="header" href="#single-operand">Single Operand</a></h3>
<p><code>SRC</code>: operand</p>
<h4 id="8-bit"><a class="header" href="#8-bit">8-bit</a></h4>
<pre><code class="language-rust ignore">TMP_XP = AL * SRC; // Signed multiplication
// TMP-XP is a signed integer at twice the width of the SRC
AX = TMP_XP[0..=15];
if SignExtend(TMP_XP[0..=7]) == TMP_XP {
    CF = 0;
    OF = 0;
} else {
    CF = 1;
    OF = 1;
}
</code></pre>
<h4 id="16-bit"><a class="header" href="#16-bit">16-bit</a></h4>
<pre><code class="language-rust ignore">TMP_XP = AX * SRC; // Signed multiplication
// TMP_XP is a signed integer at twice the width of the SRC
DX:AX = TMP_XP[0..=31];
if SignExtend(TMP_XP[0..=15]) == TMP_XP {
    CF = 0;
    OF = 0;
} else {
    CF = 1;
    OF = 1;
}
</code></pre>
<h4 id="32-bit"><a class="header" href="#32-bit">32-bit</a></h4>
<pre><code class="language-rust ignore">TMP_XP = EAX * SRC; // Signed multiplication
// TMP_XP is a signed integer at twice the width of the SRC
EDX:EAX = TMP_XP[0..=63];
if SignExtend(TMP_XP[0..=31]) == TMP_XP {
    CF = 0;
    OF = 0;
} else {
    CF = 1;
    OF = 1;
}
</code></pre>
<h4 id="64-bit"><a class="header" href="#64-bit">64-bit</a></h4>
<pre><code class="language-rust ignore">TMP_XP = RAX * SRC; // Signed multiplication
// TMP_XP is a signed integer at twice the width of the SRC
RDX:RAX = TMP_XP[0..=127];
if SignExtend(TMP_XP[0..=63]) == TMP_XP {
    CF = 0;
    OF = 0;
} else {
    CF = 1;
    OF = 1;
}
</code></pre>
<h3 id="two-operands"><a class="header" href="#two-operands">Two Operands</a></h3>
<p><code>DEST</code>: first operand<br />
<code>SRC</code>: second operand</p>
<pre><code class="language-rust ignore">TMP_XP = DEST * SRC // Signed multiplication
// TMP_XP is a signed integer at twice the width of the SRC
DEST = TruncateToOperandSize(TMP_XP);
if SignExtend(DEST) == TMP_XP {
    CF = 0;
    OF = 0;
} else {
    CF = 1;
    OF = 1;
}
</code></pre>
<h3 id="three-operands"><a class="header" href="#three-operands">Three Operands</a></h3>
<p><code>DEST</code>: first operand<br />
<code>SRC1</code>: second operand<br />
<code>SRC2</code>: third operand</p>
<pre><code class="language-rust ignore">TMP_XP = SRC1 * SRC2 // Signed multiplication
// TMP_XP is a signed integer at twice the width of the SRC1
DEST = TruncateToOperandSize(TMP_XP);
if SignExtend(DEST) == TMP_XP {
    CF = 0;
    OF = 0;
} else {
    CF = 1;
    OF = 1;
}
</code></pre>
<h2 id="flags-affected-6"><a class="header" href="#flags-affected-6">Flags Affected</a></h2>
<p>For the one operand form of the instruction, the <code>CF</code> and <code>OF</code> flags are set when significant bits are carried into the upper half of the result and cleared when the result fits exactly in the lower half of the result. For the two- and three-operand forms of the instruction, the <code>CF</code> and <code>OF</code> flags are set when the result must be truncated to fit in the destination operand size and cleared when the result fits exactly in the destination operand size. The <code>SF</code>, <code>ZF</code>, <code>AF</code>, and <code>PF</code> flags are undefined.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="mul"><a class="header" href="#mul"><code>MUL</code></a></h1>
<p>Unsigned Multiply</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Instruction</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>MUL r/m8</code></td><td style="text-align: left">Unsigned multiply (<code>AX = AL * r/m8</code>)</td></tr>
<tr><td style="text-align: left"><code>MUL r/m16</code></td><td style="text-align: left">Unsigned multiply (<code>DX:AX = AX * r/m16</code>)</td></tr>
<tr><td style="text-align: left"><code>MUL r/m32</code></td><td style="text-align: left">Unsigned multiply (<code>EDX:EAX = EAX * r/m32</code>)</td></tr>
<tr><td style="text-align: left"><code>MUL r/m64</code></td><td style="text-align: left">Unsigned multiply (<code>RDX:RAX = RAX * r/m64</code>)</td></tr>
</tbody></table>
</div>
<h2 id="description-7"><a class="header" href="#description-7">Description</a></h2>
<p>Performs an unsigned multiplication of the first operand (destination operand) and the second operand (source operand) and stores the result in the destination operand. The destination operand is an implied operand located in register <code>AL</code>, <code>AX</code> or <code>EAX</code> (depending on the size of the operand); the source operand is located in a general-purpose register or a memory location. The action of this instruction and the location of the result depends on the opcode and the operand size as shown in the table below.</p>
<p>The result is stored in register <code>AX</code>, register pair <code>DX:AX</code>, or register pair <code>EDX:EAX</code> (depending on the operand size), with the high-order bits of the product contained in register <code>AH</code>, <code>DX</code>, or <code>EDX</code>, respectively. If the high-order bits of the product are 0, the <code>CF</code> and <code>OF</code> flags are cleared; otherwise, the flags are set.</p>
<p>In 64-bit mode, the instruction’s default operation size is 32 bits. Use of the <code>REX.R</code> prefix permits access to additional registers (<code>R8</code>-<code>R15</code>). Use of the <code>REX.W</code> prefix promotes operation to 64 bits.</p>
<p>See the summary chart at the beginning of this section for encoding data and limits.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Operand Size</th><th style="text-align: left">Source 1</th><th style="text-align: left">Source 2</th><th style="text-align: left">Destination</th></tr></thead><tbody>
<tr><td style="text-align: left">Byte</td><td style="text-align: left"><code>AL</code></td><td style="text-align: left"><code>r/m8</code></td><td style="text-align: left"><code>AX</code></td></tr>
<tr><td style="text-align: left">Word</td><td style="text-align: left"><code>AX</code></td><td style="text-align: left"><code>r/m16</code></td><td style="text-align: left"><code>DX:AX</code></td></tr>
<tr><td style="text-align: left">Doubleword</td><td style="text-align: left"><code>EAX</code></td><td style="text-align: left"><code>r/m32</code></td><td style="text-align: left"><code>EDX:EAX</code></td></tr>
<tr><td style="text-align: left">Quadword</td><td style="text-align: left"><code>RAX</code></td><td style="text-align: left"><code>r/m64</code></td><td style="text-align: left"><code>RDX:RAX</code></td></tr>
</tbody></table>
</div>
<h2 id="operation-8"><a class="header" href="#operation-8">Operation</a></h2>
<p><code>SRC</code>: operand</p>
<h3 id="operandsize--8"><a class="header" href="#operandsize--8">OperandSize = 8</a></h3>
<pre><code class="language-rust ignore">AX = AL * SRC;
</code></pre>
<h3 id="operandsize--16-2"><a class="header" href="#operandsize--16-2">OperandSize = 16</a></h3>
<pre><code class="language-rust ignore">DX:AX = AX * SRC;
</code></pre>
<h3 id="operandsize--32-2"><a class="header" href="#operandsize--32-2">OperandSize = 32</a></h3>
<pre><code class="language-rust ignore">EDX:EAX = EAX * SRC;
</code></pre>
<h3 id="operandsize--64-2"><a class="header" href="#operandsize--64-2">OperandSize = 64</a></h3>
<pre><code class="language-rust  ignore">RDX:RAX = RAX * SRC;
</code></pre>
<h2 id="flags-affected-7"><a class="header" href="#flags-affected-7">Flags Affected</a></h2>
<p>The <code>OF</code> and <code>CF</code> flags are set to 0 if the upper half of the result is 0; otherwise, they are set to 1. The <code>SF</code>, <code>ZF</code>, <code>AF</code>, and <code>PF</code> flags are undefined.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="idiv"><a class="header" href="#idiv"><code>IDIV</code></a></h1>
<p>Signed Divide</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Instruction</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>IDIV r/m8</code></td><td style="text-align: left">Signed divide <code>AX</code> by <code>r/m8</code>; <code>AL</code> = Quotient, <code>AH</code> = Remainder</td></tr>
<tr><td style="text-align: left"><code>IDIV r/m16</code></td><td style="text-align: left">Signed divide <code>DX:AX</code> by <code>r/m16</code>; <code>AX</code> = Quotient, <code>DX</code> = Remainder</td></tr>
<tr><td style="text-align: left"><code>IDIV r/m32</code></td><td style="text-align: left">Signed divide <code>EDX:EAX</code> by <code>r/m32</code>; <code>EAX</code> = Quotient, <code>EDX</code> = Remainder</td></tr>
<tr><td style="text-align: left"><code>IDIV r/m64</code></td><td style="text-align: left">Signed divide <code>RDX:RAX</code> by <code>r/m64</code>; <code>RAX</code> = Quotient, <code>RDX</code> = Remainder</td></tr>
</tbody></table>
</div>
<p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:9.429760000000002em;vertical-align:-4.46488em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:4.964880000000001em;"><span style="top:-6.96488em;"><span class="pstrut" style="height:3.28811em;"></span><span class="mord"><span class="mord text"><span class="mord texttt">AL</span></span></span></span><span style="top:-4.60744em;"><span class="pstrut" style="height:3.28811em;"></span><span class="mord"><span class="mord text"><span class="mord texttt">AX</span></span></span></span><span style="top:-2.250000000000001em;"><span class="pstrut" style="height:3.28811em;"></span><span class="mord"><span class="mord text"><span class="mord texttt">EAX</span></span></span></span><span style="top:0.10743999999999976em;"><span class="pstrut" style="height:3.28811em;"></span><span class="mord"><span class="mord text"><span class="mord texttt">RAX</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:4.46488em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:4.964880000000001em;"><span style="top:-6.96488em;"><span class="pstrut" style="height:3.28811em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.28811em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord texttt">r/m8</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord texttt">AX</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693300000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-4.60744em;"><span class="pstrut" style="height:3.28811em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.28811em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord texttt">r/m16</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord texttt">DX:AX</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693300000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-2.250000000000001em;"><span class="pstrut" style="height:3.28811em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.28811em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord texttt">r/m32</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord texttt">EDX:EAX</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693300000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:0.10743999999999976em;"><span class="pstrut" style="height:3.28811em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.28811em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord texttt">r/m64</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord texttt">RDX:RAX</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693300000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:4.46488em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:4.964880000000001em;"><span style="top:-6.96488em;"><span class="pstrut" style="height:3.28811em;"></span><span class="mord"><span class="mord text"><span class="mord texttt">AH</span></span></span></span><span style="top:-4.60744em;"><span class="pstrut" style="height:3.28811em;"></span><span class="mord"><span class="mord text"><span class="mord texttt">DX</span></span></span></span><span style="top:-2.250000000000001em;"><span class="pstrut" style="height:3.28811em;"></span><span class="mord"><span class="mord text"><span class="mord texttt">EDX</span></span></span></span><span style="top:0.10743999999999976em;"><span class="pstrut" style="height:3.28811em;"></span><span class="mord"><span class="mord text"><span class="mord texttt">RDX</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:4.46488em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:4.964880000000001em;"><span style="top:-6.96488em;"><span class="pstrut" style="height:3.28811em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord text"><span class="mord texttt">AX</span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:1em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class="mord texttt">r/m8</span></span></span></span><span style="top:-4.60744em;"><span class="pstrut" style="height:3.28811em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord text"><span class="mord texttt">DX:AX</span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:1em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class="mord texttt">r/m16</span></span></span></span><span style="top:-2.250000000000001em;"><span class="pstrut" style="height:3.28811em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord text"><span class="mord texttt">EDX:EAX</span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:1em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class="mord texttt">r/m32</span></span></span></span><span style="top:0.10743999999999976em;"><span class="pstrut" style="height:3.28811em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord text"><span class="mord texttt">RDX:RAX</span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:1em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class="mord texttt">r/m64</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:4.46488em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<h2 id="description-8"><a class="header" href="#description-8">Description</a></h2>
<p>Divides the (signed) value in the <code>AX</code>, <code>DX:AX</code>, or <code>EDX:EAX</code> (dividend) by the source operand (divisor) and stores the result in the <code>AX</code> (<code>AH:AL</code>), <code>DX:AX</code>, or <code>EDX:EAX</code> registers. The source operand can be a general-purpose register or a memory location. The action of this instruction depends on the operand size (dividend/divisor).</p>
<p>Non-integral results are truncated (chopped) towards 0. The remainder is always less than the divisor in magnitude. Overflow is indicated with the <code>#DE</code> (divide error) exception rather than with the <code>CF</code> flag.</p>
<p>In 64-bit mode, the instruction’s default operation size is 32 bits. Use of the <code>REX.R</code> prefix permits access to additional registers (<code>R8</code>-<code>R15</code>). Use of the <code>REX.W</code> prefix promotes operation to 64 bits. In 64-bit mode when <code>REX.W</code> is applied, the instruction divides the signed value in <code>RDX:RAX</code> by the source operand. <code>RAX</code> contains a 64-bit quotient; <code>RDX</code> contains a 64-bit remainder.</p>
<p>See the summary chart at the beginning of this section for encoding data and limits. See the table below.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Operand Size</th><th style="text-align: left">Dividend</th><th style="text-align: left">Divisor</th><th style="text-align: left">Quotient</th><th style="text-align: left">Remainder</th><th style="text-align: left">Quotient Range</th></tr></thead><tbody>
<tr><td style="text-align: left">Word/byte</td><td style="text-align: left"><code>AX</code></td><td style="text-align: left"><code>r/m8</code></td><td style="text-align: left"><code>AL</code></td><td style="text-align: left"><code>AH</code></td><td style="text-align: left">-128 to +127</td></tr>
<tr><td style="text-align: left">Doubleword/word</td><td style="text-align: left"><code>DX:AX</code></td><td style="text-align: left"><code>r/m16</code></td><td style="text-align: left"><code>AX</code></td><td style="text-align: left"><code>DX</code></td><td style="text-align: left">-32,768 to +32,767</td></tr>
<tr><td style="text-align: left">Quadword/doubleword</td><td style="text-align: left"><code>EDX:EAX</code></td><td style="text-align: left"><code>r/m32</code></td><td style="text-align: left"><code>EAX</code></td><td style="text-align: left"><code>EDX</code></td><td style="text-align: left">-2<sup>31</sup> to +2<sup>31</sup> - 1</td></tr>
<tr><td style="text-align: left">Doublequadword/quadword</td><td style="text-align: left"><code>RDX:RAX</code></td><td style="text-align: left"><code>r/m64</code></td><td style="text-align: left"><code>RAX</code></td><td style="text-align: left"><code>RDX</code></td><td style="text-align: left">-2<sup>63</sup> to +2<sup>63</sup> - 1</td></tr>
</tbody></table>
</div>
<h2 id="operation-9"><a class="header" href="#operation-9">Operation</a></h2>
<p><code>SRC</code>: operand</p>
<h3 id="operandsize--8-1"><a class="header" href="#operandsize--8-1">OperandSize = 8</a></h3>
<pre><code class="language-rust ignore">if SRC == 0 {
<span class="boring">    DE; // divide error
</span>}

temp = AX / SRC; // signed division
if temp &gt; 0x7F || temp &lt; 0x80 {
    // if a positive result is greater than 0x7F
    // or a negative result is less than 0x80
<span class="boring">    DE; // divide error
</span>} else {
    AL = temp;
    AH = AX % SRC; // signed modulus
}
</code></pre>
<h3 id="operandsize--16-3"><a class="header" href="#operandsize--16-3">OperandSize = 16</a></h3>
<pre><code class="language-rust ignore">if SRC == 0 {
<span class="boring">    DE; // divide error
</span>}

temp = DX:AX / SRC; // signed division
if temp &gt; 0x7FFF || temp &lt; 0x8000 {
    // if a positive result is greater than 0x7FFF
    // or a negative result is less than 0x8000
<span class="boring">    DE; // divide error
</span>} else {
    AX = temp;
    DX = DX:AX % SRC; // signed modulus
}
</code></pre>
<h3 id="operandsize--32-3"><a class="header" href="#operandsize--32-3">OperandSize = 32</a></h3>
<pre><code class="language-rust ignore">if SRC == 0 {
<span class="boring">    DE; // divide error
</span>}

temp = EDX:EAX / SRC; // signed division
if temp &gt; 0x7FFF_FFFF || temp &lt; 0x8000_0000 {
    // if a positive result is greater than 0x7FFF_FFFF
    // or a negative result is less than 0x8000_0000
<span class="boring">    DE; // divide error
</span>} else {
    EAX = temp;
    EDX = EDX:EAX % SRC; // signed modulus
}
</code></pre>
<h3 id="operandsize--64-3"><a class="header" href="#operandsize--64-3">OperandSize = 64</a></h3>
<pre><code class="language-rust ignore">temp = RDX:RAX / SRC; // signed division
if temp &gt; 0x7FFF_FFFF_FFFF_FFFF || temp &lt; 0x8000_0000_0000_0000 {
    // if a positive result is greater than 0x7FFF_FFFF_FFFF_FFFF
    // or a negative result is less than 0x8000_0000_0000_0000
<span class="boring">    DE; // divide error
</span>} else {
    RAX = temp;
    RDX = RDX:RAX % SRC; // signed modulus
}
</code></pre>
<h2 id="flags-affected-8"><a class="header" href="#flags-affected-8">Flags Affected</a></h2>
<p>The <code>CF</code>, <code>OF</code>, <code>SF</code>, <code>ZF</code>, <code>AF</code>, and <code>PF</code> flags are undefined.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="div"><a class="header" href="#div"><code>DIV</code></a></h1>
<p>Unsigned Divide</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Instruction</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>DIV r/m8</code></td><td style="text-align: left">Unsigned divide <code>AX</code> by <code>r/m8</code>; <code>AL</code> = Quotient, <code>AH</code> = Remainder</td></tr>
<tr><td style="text-align: left"><code>DIV r/m16</code></td><td style="text-align: left">Unsigned divide <code>DX:AX</code> by <code>r/m16</code>; <code>AX</code> = Quotient, <code>DX</code> = Remainder</td></tr>
<tr><td style="text-align: left"><code>DIV r/m32</code></td><td style="text-align: left">Unsigned divide <code>EDX:EAX</code> by <code>r/m32</code>; <code>EAX</code> = Quotient, <code>EDX</code> = Remainder</td></tr>
<tr><td style="text-align: left"><code>DIV r/m64</code></td><td style="text-align: left">Unsigned divide <code>RDX:RAX</code> by <code>r/m64</code>; <code>RAX</code> = Quotient, <code>RDX</code> = Remainder</td></tr>
</tbody></table>
</div>
<p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:9.429760000000002em;vertical-align:-4.46488em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:4.964880000000001em;"><span style="top:-6.96488em;"><span class="pstrut" style="height:3.28811em;"></span><span class="mord"><span class="mord text"><span class="mord texttt">AL</span></span></span></span><span style="top:-4.60744em;"><span class="pstrut" style="height:3.28811em;"></span><span class="mord"><span class="mord text"><span class="mord texttt">AX</span></span></span></span><span style="top:-2.250000000000001em;"><span class="pstrut" style="height:3.28811em;"></span><span class="mord"><span class="mord text"><span class="mord texttt">EAX</span></span></span></span><span style="top:0.10743999999999976em;"><span class="pstrut" style="height:3.28811em;"></span><span class="mord"><span class="mord text"><span class="mord texttt">RAX</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:4.46488em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:4.964880000000001em;"><span style="top:-6.96488em;"><span class="pstrut" style="height:3.28811em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.28811em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord texttt">r/m8</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord texttt">AX</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693300000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-4.60744em;"><span class="pstrut" style="height:3.28811em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.28811em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord texttt">r/m16</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord texttt">DX:AX</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693300000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-2.250000000000001em;"><span class="pstrut" style="height:3.28811em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.28811em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord texttt">r/m32</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord texttt">EDX:EAX</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693300000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:0.10743999999999976em;"><span class="pstrut" style="height:3.28811em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.28811em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord texttt">r/m64</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord texttt">RDX:RAX</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693300000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:4.46488em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:4.964880000000001em;"><span style="top:-6.96488em;"><span class="pstrut" style="height:3.28811em;"></span><span class="mord"><span class="mord text"><span class="mord texttt">AH</span></span></span></span><span style="top:-4.60744em;"><span class="pstrut" style="height:3.28811em;"></span><span class="mord"><span class="mord text"><span class="mord texttt">DX</span></span></span></span><span style="top:-2.250000000000001em;"><span class="pstrut" style="height:3.28811em;"></span><span class="mord"><span class="mord text"><span class="mord texttt">EDX</span></span></span></span><span style="top:0.10743999999999976em;"><span class="pstrut" style="height:3.28811em;"></span><span class="mord"><span class="mord text"><span class="mord texttt">RDX</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:4.46488em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:4.964880000000001em;"><span style="top:-6.96488em;"><span class="pstrut" style="height:3.28811em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord text"><span class="mord texttt">AX</span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:1em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class="mord texttt">r/m8</span></span></span></span><span style="top:-4.60744em;"><span class="pstrut" style="height:3.28811em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord text"><span class="mord texttt">DX:AX</span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:1em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class="mord texttt">r/m16</span></span></span></span><span style="top:-2.250000000000001em;"><span class="pstrut" style="height:3.28811em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord text"><span class="mord texttt">EDX:EAX</span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:1em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class="mord texttt">r/m32</span></span></span></span><span style="top:0.10743999999999976em;"><span class="pstrut" style="height:3.28811em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord text"><span class="mord texttt">RDX:RAX</span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:1em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class="mord texttt">r/m64</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:4.46488em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<h2 id="description-9"><a class="header" href="#description-9">Description</a></h2>
<p>Divides unsigned the value in the <code>AX</code>, <code>DX:AX</code>, <code>EDX:EAX</code>, or <code>RDX:RAX</code> registers (dividend) by the source operand (divisor) and stores the result in the <code>AX</code> (<code>AH:AL</code>), <code>DX:AX</code>, <code>EDX:EAX</code>, or <code>RDX:RAX</code> registers. The source operand can be a general-purpose register or a memory location. The action of this instruction depends on the operand size (dividend/divisor). Division using 64-bit operand is available only in 64-bit mode.</p>
<p>Non-integral results are truncated (chopped) towards 0. The remainder is always less than the divisor in magnitude. Overflow is indicated with the <code>#DE</code> (divide error) exception rather than with the <code>CF</code> flag.</p>
<p>In 64-bit mode, the instruction’s default operation size is 32 bits. Use of the <code>REX.R</code> prefix permits access to additional registers (<code>R8</code>-<code>R15</code>). Use of the <code>REX.W</code> prefix promotes operation to 64 bits. In 64-bit mode when <code>REX.W</code> is applied, the instruction divides the unsigned value in <code>RDX:RAX</code> by the source operand and stores the quotient in <code>RAX</code>, the remainder in <code>RDX</code>.</p>
<p>See the summary chart at the beginning of this section for encoding data and limits. See the table below.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Operand Size</th><th style="text-align: left">Dividend</th><th style="text-align: left">Divisor</th><th style="text-align: left">Quotient</th><th style="text-align: left">Remainder</th><th style="text-align: left">Maximum Quotient</th></tr></thead><tbody>
<tr><td style="text-align: left">Word/byte</td><td style="text-align: left"><code>AX</code></td><td style="text-align: left"><code>r/m8</code></td><td style="text-align: left"><code>AL</code></td><td style="text-align: left"><code>AH</code></td><td style="text-align: left">255</td></tr>
<tr><td style="text-align: left">Doubleword/word</td><td style="text-align: left"><code>DX:AX</code></td><td style="text-align: left"><code>r/m16</code></td><td style="text-align: left"><code>AX</code></td><td style="text-align: left"><code>DX</code></td><td style="text-align: left">65,535</td></tr>
<tr><td style="text-align: left">Quadword/doubleword</td><td style="text-align: left"><code>EDX:EAX</code></td><td style="text-align: left"><code>r/m32</code></td><td style="text-align: left"><code>EAX</code></td><td style="text-align: left"><code>EDX</code></td><td style="text-align: left">2<sup>32</sup> - 1</td></tr>
<tr><td style="text-align: left">Doublequadword/quadword</td><td style="text-align: left"><code>RDX:RAX</code></td><td style="text-align: left"><code>r/m64</code></td><td style="text-align: left"><code>RAX</code></td><td style="text-align: left"><code>RDX</code></td><td style="text-align: left">2<sup>64</sup> - 1</td></tr>
</tbody></table>
</div>
<h2 id="operation-10"><a class="header" href="#operation-10">Operation</a></h2>
<p><code>SRC</code>: operand</p>
<h3 id="operandsize--8-2"><a class="header" href="#operandsize--8-2">OperandSize = 8</a></h3>
<pre><code class="language-rust ignore">if SRC == 0 {
<span class="boring">    DE; // divide error
</span>}

temp = AX / SRC;
if temp &gt; 0xFF {
<span class="boring">    DE; // divide error
</span>} else {
    AL = temp;
    AH = AX % SRC;
}
</code></pre>
<h3 id="operandsize--16-4"><a class="header" href="#operandsize--16-4">OperandSize = 16</a></h3>
<pre><code class="language-rust ignore">if SRC == 0 {
<span class="boring">    DE; // divide error
</span>}

temp = DX:AX / SRC;
if temp &gt; 0xFFFF {
<span class="boring">    DE; // divide error
</span>} else {
    AX = temp;
    DX = DX:AX % SRC;
}
</code></pre>
<h3 id="operandsize--32-4"><a class="header" href="#operandsize--32-4">OperandSize = 32</a></h3>
<pre><code class="language-rust ignore">if SRC == 0 {
<span class="boring">    DE; // divide error
</span>}

temp = EDX:EAX / SRC;
if temp &gt; 0xFFFF_FFFF {
<span class="boring">    DE; // divide error
</span>} else {
    EAX = temp;
    EDX = EDX:EAX % SRC;
}
</code></pre>
<h3 id="operandsize--64-4"><a class="header" href="#operandsize--64-4">OperandSize = 64</a></h3>
<pre><code class="language-rust ignore">if SRC == 0 {
<span class="boring">    DE; // divide error
</span>}

temp = RDX:RAX / SRC;
if temp &gt; 0xFFFF_FFFF_FFFF_FFFF {
<span class="boring">    DE; // divide error
</span>} else {
    RAX = temp;
    RDX = RDX:RAX % SRC;
}
</code></pre>
<h2 id="flags-affected-9"><a class="header" href="#flags-affected-9">Flags Affected</a></h2>
<p>The <code>CF</code>, <code>OF</code>, <code>SF</code>, <code>ZF</code>, <code>AF</code>, and <code>PF</code> flags are undefined.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="inc"><a class="header" href="#inc"><code>INC</code></a></h1>
<p>Increment by 1</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Instruction</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>INC r/m8</code></td><td style="text-align: left">Increment <code>r/m8</code> by 1</td></tr>
<tr><td style="text-align: left"><code>INC r/m16</code></td><td style="text-align: left">Increment <code>r/m16</code> by 1</td></tr>
<tr><td style="text-align: left"><code>INC r/m32</code></td><td style="text-align: left">Increment <code>r/m32</code> by 1</td></tr>
<tr><td style="text-align: left"><code>INC r/m64</code></td><td style="text-align: left">Increment <code>r/m64</code> by 1</td></tr>
</tbody></table>
</div>
<h2 id="description-10"><a class="header" href="#description-10">Description</a></h2>
<p>Adds 1 to the destination operand, while preserving the state of the <code>CF</code> flag. The destination operand can be a register or a memory location. This instruction allows a loop counter to be updated without disturbing the <code>CF</code> flag. (Use a <code>ADD</code> instruction with an immediate operand of 1 to perform an increment operation that does updates the <code>CF</code> flag.)</p>
<p>This instruction can be used with a <code>LOCK</code> prefix to allow the instruction to be executed atomically.</p>
<p>In 64-bit mode, <code>INC r16</code> and <code>INC r32</code> are not encodable (because opcodes <code>0x40</code> through <code>0x47</code> are <code>REX</code> prefixes). Otherwise, the instruction’s 64-bit mode default operation size is 32 bits. Use of the <code>REX.R</code> prefix permits access to additional registers (<code>R8</code>-<code>R15</code>). Use of the <code>REX.W</code> prefix promotes operation to 64 bits.</p>
<h2 id="operation-11"><a class="header" href="#operation-11">Operation</a></h2>
<p><code>DEST</code>: operand</p>
<pre><code class="language-rust ignore">DEST = DEST + 1;
</code></pre>
<h2 id="flags-affected-10"><a class="header" href="#flags-affected-10">Flags Affected</a></h2>
<p>The <code>CF</code> flag is not affected. The <code>OF</code>, <code>SF</code>, <code>ZF</code>, <code>AF</code>, and <code>PF</code> flags are set according to the result.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="dec"><a class="header" href="#dec"><code>DEC</code></a></h1>
<p>Decrement by 1</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Instruction</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>DEC r/m8</code></td><td style="text-align: left">Decrement <code>r/m8</code> by 1</td></tr>
<tr><td style="text-align: left"><code>DEC r/m16</code></td><td style="text-align: left">Decrement <code>r/m16</code> by 1</td></tr>
<tr><td style="text-align: left"><code>DEC r/m32</code></td><td style="text-align: left">Decrement <code>r/m32</code> by 1</td></tr>
<tr><td style="text-align: left"><code>DEC r/m64</code></td><td style="text-align: left">Decrement <code>r/m64</code> by 1</td></tr>
</tbody></table>
</div>
<h2 id="description-11"><a class="header" href="#description-11">Description</a></h2>
<p>Subtracts 1 from the destination operand, while preserving the state of the <code>CF</code> flag. The destination operand can be a register or a memory location. This instruction allows a loop counter to be updated without disturbing the <code>CF</code> flag. (To perform a decrement operation that updates the <code>CF</code> flag, use a SUB instruction with an immediate operand of 1.)</p>
<p>This instruction can be used with a <code>LOCK</code> prefix to allow the instruction to be executed atomically.</p>
<p>In 64-bit mode, <code>DEC r16</code> and <code>DEC r32</code> are not encodable (because opcodes <code>0x48</code> through <code>0x4F</code> are <code>REX</code> prefixes). Otherwise, the instruction’s 64-bit mode default operation size is 32 bits. Use of the <code>REX.R</code> prefix permits access to additional registers (<code>R8</code>-<code>R15</code>). Use of the <code>REX.W</code> prefix promotes operation to 64 bits.</p>
<p>See the summary chart at the beginning of this section for encoding data and limits.</p>
<h2 id="operation-12"><a class="header" href="#operation-12">Operation</a></h2>
<p><code>DEST</code>: operand</p>
<pre><code class="language-rust ignore">DEST = DEST - 1;
</code></pre>
<h2 id="flags-affected-11"><a class="header" href="#flags-affected-11">Flags Affected</a></h2>
<p>The <code>CF</code> flag is not affected. The <code>OF</code>, <code>SF</code>, <code>ZF</code>, <code>AF</code>, and <code>PF</code> flags are set according to the result.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="neg"><a class="header" href="#neg"><code>NEG</code></a></h1>
<p>Two’s Complement Negation</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Instruction</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>NEG r/m8</code></td><td style="text-align: left">Two’s complement negate <code>r/m8</code></td></tr>
<tr><td style="text-align: left"><code>NEG r/m16</code></td><td style="text-align: left">Two’s complement negate <code>r/m16</code></td></tr>
<tr><td style="text-align: left"><code>NEG r/m32</code></td><td style="text-align: left">Two’s complement negate <code>r/m32</code></td></tr>
<tr><td style="text-align: left"><code>NEG r/m64</code></td><td style="text-align: left">Two’s complement negate <code>r/m64</code></td></tr>
</tbody></table>
</div>
<h2 id="description-12"><a class="header" href="#description-12">Description</a></h2>
<p>Replaces the value of operand (the destination operand) with its two’s complement. (This operation is equivalent to subtracting the operand from 0.) The destination operand is located in a general-purpose register or a memory location.</p>
<p>This instruction can be used with a <code>LOCK</code> prefix to allow the instruction to be executed atomically.</p>
<p>In 64-bit mode, the instruction’s default operation size is 32 bits. Using a <code>REX</code> prefix in the form of <code>REX.R</code> permits access to additional registers (<code>R8</code>-<code>R15</code>). Using a <code>REX</code> prefix in the form of <code>REX.W</code> promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.</p>
<h2 id="operation-13"><a class="header" href="#operation-13">Operation</a></h2>
<p><code>DEST</code>: operand</p>
<pre><code class="language-rust ignore">if DEST == 0 {
    CF = 0;
} else {
    CF = 1;
}
DEST = -DEST;
</code></pre>
<h2 id="flags-affected-12"><a class="header" href="#flags-affected-12">Flags Affected</a></h2>
<p>The <code>CF</code> flag set to 0 if the source operand is 0; otherwise it is set to 1. The <code>OF</code>, <code>SF</code>, <code>ZF</code>, <code>AF</code>, and <code>PF</code> flags are set according to the result.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="cmp"><a class="header" href="#cmp"><code>CMP</code></a></h1>
<p>Compare Two Operands</p>
<p>The same operation as <a href="instructions/binary-arithmetic-instructions/../binary-arithmetic-instructions/sub.html"><code>SUB</code></a>, but do not save the result in a register, only keep the flags.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Instruction</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>CMP r/m8, imm8</code></td><td style="text-align: left">Compare <code>imm8</code> with <code>r/m8</code></td></tr>
<tr><td style="text-align: left"><code>CMP r/m16, imm16</code></td><td style="text-align: left">Compare <code>imm16</code> with <code>r/m16</code></td></tr>
<tr><td style="text-align: left"><code>CMP r/m32, imm32</code></td><td style="text-align: left">Compare <code>imm32</code> with <code>r/m32</code></td></tr>
<tr><td style="text-align: left"><code>CMP r/m64, imm32</code></td><td style="text-align: left">Compare sign-extended <code>imm32</code> with <code>r/m64</code></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>CMP r/m16, imm8</code></td><td style="text-align: left">Compare sign-extended <code>imm8</code> with <code>r/m16</code></td></tr>
<tr><td style="text-align: left"><code>CMP r/m32, imm8</code></td><td style="text-align: left">Compare sign-extended <code>imm8</code> with <code>r/m32</code></td></tr>
<tr><td style="text-align: left"><code>CMP r/m64, imm8</code></td><td style="text-align: left">Compare sign-extended <code>imm8</code> with <code>r/m64</code></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>CMP r/m8, r8</code></td><td style="text-align: left">Compare <code>r8</code> with <code>r/m8</code></td></tr>
<tr><td style="text-align: left"><code>CMP r/m16, r16</code></td><td style="text-align: left">Compare <code>r16</code> with <code>r/m16</code></td></tr>
<tr><td style="text-align: left"><code>CMP r/m32, r32</code></td><td style="text-align: left">Compare <code>r32</code> with <code>r/m32</code></td></tr>
<tr><td style="text-align: left"><code>CMP r/m64, r64</code></td><td style="text-align: left">Compare <code>r64</code> with <code>r/m64</code></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>CMP r8, r/m8</code></td><td style="text-align: left">Compare <code>r/m8</code> with <code>r8</code></td></tr>
<tr><td style="text-align: left"><code>CMP r16, r/m16</code></td><td style="text-align: left">Compare <code>r/m16</code> with <code>r16</code></td></tr>
<tr><td style="text-align: left"><code>CMP r32, r/m32</code></td><td style="text-align: left">Compare <code>r/m32</code> with <code>r32</code></td></tr>
<tr><td style="text-align: left"><code>CMP r64, r/m64</code></td><td style="text-align: left">Compare <code>r/m64</code> with <code>r64</code></td></tr>
</tbody></table>
</div>
<p>Intuition:<br />
Condition codes are read in order of the operands. For example:</p>
<pre><code class="language-x86asm">cmp     rax, 10
jg      .label
</code></pre>
<p>“jump if <code>RAX</code> is greater than <code>10</code>”</p>
<h2 id="description-13"><a class="header" href="#description-13">Description</a></h2>
<p>Compares the first source operand with the second source operand and sets the status flags in the <code>EFLAGS</code> register according to the results. The comparison is performed by subtracting the second operand from the first operand and then setting the status flags in the same manner as the SUB instruction. When an immediate value is used as an operand, it is sign-extended to the length of the first operand.</p>
<p>The condition codes used by the <code>Jcc</code>, <code>CMOVcc</code>, and <code>SETcc</code> instructions are based on the results of a <code>CMP</code> instruction. Appendix B, “EFLAGS Condition Codes,” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, shows the relationship of the status flags and the condition codes.</p>
<p>In 64-bit mode, the instruction’s default operation size is 32 bits. Use of the <code>REX.R</code> prefix permits access to additional registers (<code>R8</code>-<code>R15</code>). Use of the <code>REX.W</code> prefix promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.</p>
<h2 id="operation-14"><a class="header" href="#operation-14">Operation</a></h2>
<p><code>SRC1</code>: first operand<br />
<code>SRC2</code>: second operand</p>
<pre><code class="language-rust ignore">temp = SRC1 - SignExtend(SRC2);
ModifyStatusFlags(); // modify status flags in the same manner as the SUB instruction
</code></pre>
<h2 id="flags-affected-13"><a class="header" href="#flags-affected-13">Flags Affected</a></h2>
<p>The <code>CF</code>, <code>OF</code>, <code>SF</code>, <code>ZF</code>, <code>AF</code>, and <code>PF</code> flags are set according to the result.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="logical-instructions-1"><a class="header" href="#logical-instructions-1">Logical Instructions</a></h1>
<!-- ANCHOR: table -->
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Mnemonic</th><th style="text-align: left">Summary</th></tr></thead><tbody>
<tr><td style="text-align: left"><a href="instructions/logical-instructions/and.html"><code>AND</code></a></td><td style="text-align: left">Perform Bitwise Logical AND</td></tr>
<tr><td style="text-align: left"><a href="instructions/logical-instructions/or.html"><code>OR</code></a></td><td style="text-align: left">Perform Bitwise Logical OR</td></tr>
<tr><td style="text-align: left"><a href="instructions/logical-instructions/xor.html"><code>XOR</code></a></td><td style="text-align: left">Perform Bitwise Logical Exclusive OR</td></tr>
<tr><td style="text-align: left"><a href="instructions/logical-instructions/not.html"><code>NOT</code></a></td><td style="text-align: left">Perform Bitwise Logical NOT</td></tr>
</tbody></table>
</div><!-- ANCHOR_END: table -->
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="and"><a class="header" href="#and"><code>AND</code></a></h1>
<p>Logical AND</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Instruction</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>AND r/m8, imm8</code></td><td style="text-align: left"><code>r/m8</code> AND <code>imm8</code></td></tr>
<tr><td style="text-align: left"><code>AND r/m16, imm16</code></td><td style="text-align: left"><code>r/m16</code> AND <code>imm16</code></td></tr>
<tr><td style="text-align: left"><code>AND r/m32, imm32</code></td><td style="text-align: left"><code>r/m32</code> AND <code>imm32</code></td></tr>
<tr><td style="text-align: left"><code>AND r/m64, imm32</code></td><td style="text-align: left"><code>r/m64</code> AND <code>imm32</code> (sign-extended)</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>AND r/m16, imm8</code></td><td style="text-align: left"><code>r/m16</code> AND <code>imm8</code> (sign-extended)</td></tr>
<tr><td style="text-align: left"><code>AND r/m32, imm8</code></td><td style="text-align: left"><code>r/m32</code> AND <code>imm8</code> (sign-extended)</td></tr>
<tr><td style="text-align: left"><code>AND r/m64, imm8</code></td><td style="text-align: left"><code>r/m64</code> AND <code>imm8</code> (sign-extended)</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>AND r/m8, r8</code></td><td style="text-align: left"><code>r/m8</code> AND <code>r8</code></td></tr>
<tr><td style="text-align: left"><code>AND r/m16, r16</code></td><td style="text-align: left"><code>r/m16</code> AND <code>r16</code></td></tr>
<tr><td style="text-align: left"><code>AND r/m32, r32</code></td><td style="text-align: left"><code>r/m32</code> AND <code>r32</code></td></tr>
<tr><td style="text-align: left"><code>AND r/m64, r64</code></td><td style="text-align: left"><code>r/m64</code> AND <code>r64</code></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>AND r8, r/m8</code></td><td style="text-align: left"><code>r8</code> AND <code>r/m8</code></td></tr>
<tr><td style="text-align: left"><code>AND r16, r/m16</code></td><td style="text-align: left"><code>r16</code> AND <code>r/m16</code></td></tr>
<tr><td style="text-align: left"><code>AND r32, r/m32</code></td><td style="text-align: left"><code>r32</code> AND <code>r/m32</code></td></tr>
<tr><td style="text-align: left"><code>AND r64, r/m64</code></td><td style="text-align: left"><code>r64</code> AND <code>r/m64</code></td></tr>
</tbody></table>
</div>
<h2 id="description-14"><a class="header" href="#description-14">Description</a></h2>
<p>Performs a bitwise <code>AND</code> operation on the destination (first) and source (second) operands and stores the result in the destination operand location. The source operand can be an immediate, a register, or a memory location; the destination operand can be a register or a memory location. (However, two memory operands cannot be used in one instruction.) Each bit of the result is set to 1 if both corresponding bits of the first and second operands are 1; otherwise, it is set to 0.</p>
<p>This instruction can be used with a <code>LOCK</code> prefix to allow the it to be executed atomically.</p>
<p>In 64-bit mode, the instruction’s default operation size is 32 bits. Using a <code>REX</code> prefix in the form of <code>REX.R</code> permits access to additional registers (<code>R8</code>-<code>R15</code>). Using a <code>REX</code> prefix in the form of <code>REX.W</code> promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.</p>
<h2 id="operation-15"><a class="header" href="#operation-15">Operation</a></h2>
<p><code>DEST</code>: first operand<br />
<code>SRC</code>: second operand</p>
<pre><code class="language-rust ignore">DEST = DEST &amp; SRC;
</code></pre>
<h2 id="flags-affected-14"><a class="header" href="#flags-affected-14">Flags Affected</a></h2>
<p>The <code>OF</code> and <code>CF</code> flags are cleared; the <code>SF</code>, <code>ZF</code>, and <code>PF</code> flags are set according to the result. The state of the <code>AF</code> flag is undefined.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="or"><a class="header" href="#or"><code>OR</code></a></h1>
<p>Logical Inclusive OR</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Instruction</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>OR r/m8, imm8</code></td><td style="text-align: left"><code>r/m8</code> OR <code>imm8</code></td></tr>
<tr><td style="text-align: left"><code>OR r/m16, imm16</code></td><td style="text-align: left"><code>r/m16</code> OR <code>imm16</code></td></tr>
<tr><td style="text-align: left"><code>OR r/m32, imm32</code></td><td style="text-align: left"><code>r/m32</code> OR <code>imm32</code></td></tr>
<tr><td style="text-align: left"><code>OR r/m64, imm32</code></td><td style="text-align: left"><code>r/m64</code> OR <code>imm32</code> (sign-extended)</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>OR r/m16, imm8</code></td><td style="text-align: left"><code>r/m16</code> OR <code>imm8</code> (sign-extended)</td></tr>
<tr><td style="text-align: left"><code>OR r/m32, imm8</code></td><td style="text-align: left"><code>r/m32</code> OR <code>imm8</code> (sign-extended)</td></tr>
<tr><td style="text-align: left"><code>OR r/m64, imm8</code></td><td style="text-align: left"><code>r/m64</code> OR <code>imm8</code> (sign-extended)</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>OR r/m8, r8</code></td><td style="text-align: left"><code>r/m8</code> OR <code>r8</code></td></tr>
<tr><td style="text-align: left"><code>OR r/m16, r16</code></td><td style="text-align: left"><code>r/m16</code> OR <code>r16</code></td></tr>
<tr><td style="text-align: left"><code>OR r/m32, r32</code></td><td style="text-align: left"><code>r/m32</code> OR <code>r32</code></td></tr>
<tr><td style="text-align: left"><code>OR r/m64, r64</code></td><td style="text-align: left"><code>r/m64</code> OR <code>r64</code></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>OR r8, r/m8</code></td><td style="text-align: left"><code>r8</code> OR <code>r/m8</code></td></tr>
<tr><td style="text-align: left"><code>OR r16, r/m16</code></td><td style="text-align: left"><code>r16</code> OR <code>r/m16</code></td></tr>
<tr><td style="text-align: left"><code>OR r32, r/m32</code></td><td style="text-align: left"><code>r32</code> OR <code>r/m32</code></td></tr>
<tr><td style="text-align: left"><code>OR r64, r/m64</code></td><td style="text-align: left"><code>r64</code> OR <code>r/m64</code></td></tr>
</tbody></table>
</div>
<h2 id="description-15"><a class="header" href="#description-15">Description</a></h2>
<p>Performs a bitwise inclusive <code>OR</code> operation between the destination (first) and source (second) operands and stores the result in the destination operand location. The source operand can be an immediate, a register, or a memory location; the destination operand can be a register or a memory location. (However, two memory operands cannot be used in one instruction.) Each bit of the result of the <code>OR</code> instruction is set to 0 if both corresponding bits of the first and second operands are 0; otherwise, each bit is set to 1.</p>
<p>This instruction can be used with a <code>LOCK</code> prefix to allow the instruction to be executed atomically.</p>
<p>In 64-bit mode, the instruction’s default operation size is 32 bits. Using a <code>REX</code> prefix in the form of <code>REX.R</code> permits access to additional registers (<code>R8</code>-<code>R15</code>). Using a <code>REX</code> prefix in the form of <code>REX.W</code> promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.</p>
<h2 id="operation-16"><a class="header" href="#operation-16">Operation</a></h2>
<p><code>DEST</code>: first operand<br />
<code>SRC</code>: second operand</p>
<pre><code class="language-rust ignore">DEST = DEST | SRC;
</code></pre>
<h2 id="flags-affected-15"><a class="header" href="#flags-affected-15">Flags Affected</a></h2>
<p>The <code>OF</code> and <code>CF</code> flags are cleared; the <code>SF</code>, <code>ZF</code>, and <code>PF</code> flags are set according to the result. The state of the <code>AF</code> flag is undefined.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="xor"><a class="header" href="#xor"><code>XOR</code></a></h1>
<p>Logical Exclusive OR</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Instruction</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>XOR r/m8, imm8</code></td><td style="text-align: left"><code>r/m8</code> XOR <code>imm8</code></td></tr>
<tr><td style="text-align: left"><code>XOR r/m16, imm16</code></td><td style="text-align: left"><code>r/m16</code> XOR <code>imm16</code></td></tr>
<tr><td style="text-align: left"><code>XOR r/m32, imm32</code></td><td style="text-align: left"><code>r/m32</code> XOR <code>imm32</code></td></tr>
<tr><td style="text-align: left"><code>XOR r/m64, imm32</code></td><td style="text-align: left"><code>r/m64</code> XOR <code>imm32</code> (sign-extended)</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>XOR r/m16, imm8</code></td><td style="text-align: left"><code>r/m16</code> XOR <code>imm8</code> (sign-extended)</td></tr>
<tr><td style="text-align: left"><code>XOR r/m32, imm8</code></td><td style="text-align: left"><code>r/m32</code> XOR <code>imm8</code> (sign-extended)</td></tr>
<tr><td style="text-align: left"><code>XOR r/m64, imm8</code></td><td style="text-align: left"><code>r/m64</code> XOR <code>imm8</code> (sign-extended)</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>XOR r/m8, r8</code></td><td style="text-align: left"><code>r/m8</code> XOR <code>r8</code></td></tr>
<tr><td style="text-align: left"><code>XOR r/m16, r16</code></td><td style="text-align: left"><code>r/m16</code> XOR <code>r16</code></td></tr>
<tr><td style="text-align: left"><code>XOR r/m32, r32</code></td><td style="text-align: left"><code>r/m32</code> XOR <code>r32</code></td></tr>
<tr><td style="text-align: left"><code>XOR r/m64, r64</code></td><td style="text-align: left"><code>r/m64</code> XOR <code>r64</code></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>XOR r8, r/m8</code></td><td style="text-align: left"><code>r8</code> XOR <code>r/m8</code></td></tr>
<tr><td style="text-align: left"><code>XOR r16, r/m16</code></td><td style="text-align: left"><code>r16</code> XOR <code>r/m16</code></td></tr>
<tr><td style="text-align: left"><code>XOR r32, r/m32</code></td><td style="text-align: left"><code>r32</code> XOR <code>r/m32</code></td></tr>
<tr><td style="text-align: left"><code>XOR r64, r/m64</code></td><td style="text-align: left"><code>r64</code> XOR <code>r/m64</code></td></tr>
</tbody></table>
</div>
<h2 id="description-16"><a class="header" href="#description-16">Description</a></h2>
<p>Performs a bitwise exclusive <code>OR</code> (<code>XOR</code>) operation on the destination (first) and source (second) operands and stores the result in the destination operand location. The source operand can be an immediate, a register, or a memory location; the destination operand can be a register or a memory location. (However, two memory operands cannot be used in one instruction.) Each bit of the result is 1 if the corresponding bits of the operands are different; each bit is 0 if the corresponding bits are the same.</p>
<p>This instruction can be used with a <code>LOCK</code> prefix to allow the instruction to be executed atomically.</p>
<p>In 64-bit mode, using a <code>REX</code> prefix in the form of <code>REX.R</code> permits access to additional registers (<code>R8</code>-<code>R15</code>). Using a
<code>REX</code> prefix in the form of <code>REX.W</code> promotes operation to 64 bits. See the summary chart at the beginning of this
section for encoding data and limits.</p>
<h2 id="operation-17"><a class="header" href="#operation-17">Operation</a></h2>
<p><code>DEST</code>: first operand<br />
<code>SRC</code>: second operand</p>
<pre><code class="language-rust ignore">DEST = DEST ^ SRC;
</code></pre>
<h2 id="flags-affected-16"><a class="header" href="#flags-affected-16">Flags Affected</a></h2>
<p>The <code>OF</code> and <code>CF</code> flags are cleared; the <code>SF</code>, <code>ZF</code>, and <code>PF</code> flags are set according to the result. The state of the <code>AF</code> flag is undefined.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="not"><a class="header" href="#not"><code>NOT</code></a></h1>
<p>One’s Complement Negation</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Instruction</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>NOT r/m8</code></td><td style="text-align: left">Reverse each bit of <code>r/m8</code></td></tr>
<tr><td style="text-align: left"><code>NOT r/m16</code></td><td style="text-align: left">Reverse each bit of <code>r/m16</code></td></tr>
<tr><td style="text-align: left"><code>NOT r/m32</code></td><td style="text-align: left">Reverse each bit of <code>r/m32</code></td></tr>
<tr><td style="text-align: left"><code>NOT r/m64</code></td><td style="text-align: left">Reverse each bit of <code>r/m64</code></td></tr>
</tbody></table>
</div>
<h2 id="description-17"><a class="header" href="#description-17">Description</a></h2>
<p>Performs a bitwise <code>NOT</code> operation (each 1 is set to 0, and each 0 is set to 1) on the destination operand and stores the result in the destination operand location. The destination operand can be a register or a memory location.</p>
<p>This instruction can be used with a <code>LOCK</code> prefix to allow the instruction to be executed atomically.</p>
<p>In 64-bit mode, the instruction’s default operation size is 32 bits. Using a <code>REX</code> prefix in the form of <code>REX.R</code> permits access to additional registers (<code>R8</code>-<code>R15</code>). Using a <code>REX</code> prefix in the form of <code>REX.W</code> promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.</p>
<h2 id="operation-18"><a class="header" href="#operation-18">Operation</a></h2>
<p><code>DEST</code>: operand</p>
<pre><code class="language-rust ignore">DEST = ~DEST;
</code></pre>
<h2 id="flags-affected-17"><a class="header" href="#flags-affected-17">Flags Affected</a></h2>
<p>None.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="shift-and-rotate-instructions-1"><a class="header" href="#shift-and-rotate-instructions-1">Shift and Rotate Instructions</a></h1>
<!-- ANCHOR: table -->
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Mnemonic</th><th style="text-align: left">Summary</th></tr></thead><tbody>
<tr><td style="text-align: left"><a href="instructions/shift-and-rotate-instructions/sal,sar,shl,shr.html"><code>SAR</code></a></td><td style="text-align: left">Shift Arithmetic Right</td></tr>
<tr><td style="text-align: left"><a href="instructions/shift-and-rotate-instructions/sal,sar,shl,shr.html"><code>SHR</code></a></td><td style="text-align: left">Shift Logical Right</td></tr>
<tr><td style="text-align: left"><a href="instructions/shift-and-rotate-instructions/sal,sar,shl,shr.html"><code>SAL</code>|<code>SHL</code></a></td><td style="text-align: left">Shift Arithmetic Left/Shift Logical Left</td></tr>
</tbody></table>
</div><!-- ANCHOR_END: table -->
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="salsarshlshr"><a class="header" href="#salsarshlshr"><code>SAL</code>|<code>SAR</code>|<code>SHL</code>|<code>SHR</code></a></h1>
<p>Shift</p>
<p><code>SAL</code>: Shift Arithmetic Left<br />
<code>SAR</code>: Shift Arithmetic Right</p>
<p><code>SHL</code>: Shift Logical Left<br />
<code>SHR</code>: Shift Logical Right</p>
<p>Right Arithmetic Shifts preserve the sign by filling with the same value as the sign bit.<br />
Right Logical Shift always fill with 0s.</p>
<p>Left Shifts always fill with 0s, thus <code>SAL</code> and <code>SHL</code> are synonymous.</p>
<h2 id="salshl"><a class="header" href="#salshl"><code>SAL</code>|<code>SHL</code></a></h2>
<p><code>SAL</code> and <code>SHL</code> are synonymous.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Instruction</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>SAL/SHL r/m8, imm8</code></td><td style="text-align: left">Shift <code>r/m8</code> to the left, <code>imm8</code> times, filling with 0</td></tr>
<tr><td style="text-align: left"><code>SAL/SHL r/m16, imm8</code></td><td style="text-align: left">Shift <code>r/m16</code> to the left, <code>imm8</code> times, filling with 0</td></tr>
<tr><td style="text-align: left"><code>SAL/SHL r/m32, imm8</code></td><td style="text-align: left">Shift <code>r/m32</code> to the left, <code>imm8</code> times, filling with 0</td></tr>
<tr><td style="text-align: left"><code>SAL/SHL r/m64, imm8</code></td><td style="text-align: left">Shift <code>r/m64</code> to the left, <code>imm8</code> times, filling with 0</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>SAL/SHL r/m8, CL</code></td><td style="text-align: left">Shift <code>r/m8</code> to the left, <code>CL</code> times, filling with 0</td></tr>
<tr><td style="text-align: left"><code>SAL/SHL r/m16, CL</code></td><td style="text-align: left">Shift <code>r/m16</code> to the left, <code>CL</code> times, filling with 0</td></tr>
<tr><td style="text-align: left"><code>SAL/SHL r/m32, CL</code></td><td style="text-align: left">Shift <code>r/m32</code> to the left, <code>CL</code> times, filling with 0</td></tr>
<tr><td style="text-align: left"><code>SAL/SHL r/m64, CL</code></td><td style="text-align: left">Shift <code>r/m64</code> to the left, <code>CL</code> times, filling with 0</td></tr>
</tbody></table>
</div>
<h2 id="sar"><a class="header" href="#sar"><code>SAR</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Instruction</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>SAR r/m8, imm8</code></td><td style="text-align: left">Shift <code>r/m8</code> to the right, <code>imm8</code> times, preserving the sign</td></tr>
<tr><td style="text-align: left"><code>SAR r/m16, imm8</code></td><td style="text-align: left">Shift <code>r/m16</code> to the right, <code>imm8</code> times, preserving the sign</td></tr>
<tr><td style="text-align: left"><code>SAR r/m32, imm8</code></td><td style="text-align: left">Shift <code>r/m32</code> to the right, <code>imm8</code> times, preserving the sign</td></tr>
<tr><td style="text-align: left"><code>SAR r/m64, imm8</code></td><td style="text-align: left">Shift <code>r/m64</code> to the right, <code>imm8</code> times, preserving the sign</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>SAR r/m8, CL</code></td><td style="text-align: left">Shift <code>r/m8</code> to the right, <code>CL</code> times, preserving the sign</td></tr>
<tr><td style="text-align: left"><code>SAR r/m16, CL</code></td><td style="text-align: left">Shift <code>r/m16</code> to the right, <code>CL</code> times, preserving the sign</td></tr>
<tr><td style="text-align: left"><code>SAR r/m32, CL</code></td><td style="text-align: left">Shift <code>r/m32</code> to the right, <code>CL</code> times, preserving the sign</td></tr>
<tr><td style="text-align: left"><code>SAR r/m64, CL</code></td><td style="text-align: left">Shift <code>r/m64</code> to the right, <code>CL</code> times, preserving the sign</td></tr>
</tbody></table>
</div>
<h2 id="shr"><a class="header" href="#shr"><code>SHR</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Instruction</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>SHR r/m8, imm8</code></td><td style="text-align: left">Shift <code>r/m8</code> to the right, <code>imm8</code> times, filling with 0</td></tr>
<tr><td style="text-align: left"><code>SHR r/m16, imm8</code></td><td style="text-align: left">Shift <code>r/m16</code> to the right, <code>imm8</code> times, filling with 0</td></tr>
<tr><td style="text-align: left"><code>SHR r/m32, imm8</code></td><td style="text-align: left">Shift <code>r/m32</code> to the right, <code>imm8</code> times, filling with 0</td></tr>
<tr><td style="text-align: left"><code>SHR r/m64, imm8</code></td><td style="text-align: left">Shift <code>r/m64</code> to the right, <code>imm8</code> times, filling with 0</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>SHR r/m8, CL</code></td><td style="text-align: left">Shift <code>r/m8</code> to the right, <code>CL</code> times, filling with 0</td></tr>
<tr><td style="text-align: left"><code>SHR r/m16, CL</code></td><td style="text-align: left">Shift <code>r/m16</code> to the right, <code>CL</code> times, filling with 0</td></tr>
<tr><td style="text-align: left"><code>SHR r/m32, CL</code></td><td style="text-align: left">Shift <code>r/m32</code> to the right, <code>CL</code> times, filling with 0</td></tr>
<tr><td style="text-align: left"><code>SHR r/m64, CL</code></td><td style="text-align: left">Shift <code>r/m64</code> to the right, <code>CL</code> times, filling with 0</td></tr>
</tbody></table>
</div>
<h2 id="description-18"><a class="header" href="#description-18">Description</a></h2>
<p>Shifts the bits in the first operand (destination operand) to the left or right by the number of bits specified in the second operand (count operand). Bits shifted beyond the destination operand boundary are first shifted into the <code>CF</code> flag, then discarded. At the end of the shift operation, the <code>CF</code> flag contains the last bit shifted out of the destination operand.</p>
<p>The destination operand can be a register or a memory location. The count operand can be an immediate value or the <code>CL</code> register. The count is masked to 5 bits (or 6 bits if in 64-bit mode and <code>REX.W</code> is used). The count range is limited to 0 to 31 (or 63 if 64-bit mode and <code>REX.W</code> is used). A special opcode encoding is provided for a count of 1.</p>
<p>The shift arithmetic left (<code>SAL</code>) and shift logical left (<code>SHL</code>) instructions perform the same operation; they shift the bits in the destination operand to the left (toward more significant bit locations). For each shift count, the most significant bit of the destination operand is shifted into the <code>CF</code> flag, and the least significant bit is cleared (see Figure 7-7 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1).</p>
<p>The shift arithmetic right (<code>SAR</code>) and shift logical right (<code>SHR</code>) instructions shift the bits of the destination operand to the right (toward less significant bit locations). For each shift count, the least significant bit of the destination operand is shifted into the <code>CF</code> flag, and the most significant bit is either set or cleared depending on the instruction type. The <code>SHR</code> instruction clears the most significant bit (see Figure 7-8 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1); the <code>SAR</code> instruction sets or clears the most significant bit to correspond to the sign (most significant bit) of the original value in the destination operand. In effect, the <code>SAR</code> instruction fills the empty bit position’s shifted value with the sign of the unshifted value (see Figure 7-9 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1).</p>
<p>The <code>SAR</code> and <code>SHR</code> instructions can be used to perform signed or unsigned division, respectively, of the destination operand by powers of 2. For example, using the <code>SAR</code> instruction to shift a signed integer 1 bit to the right divides the value by 2.</p>
<p>Using the <code>SAR</code> instruction to perform a division operation does not produce the same result as the <code>IDIV</code> instruction. The quotient from the <code>IDIV</code> instruction is rounded toward zero, whereas the “quotient” of the <code>SAR</code> instruction is rounded toward negative infinity. This difference is apparent only for negative numbers. For example, when the <code>IDIV</code> instruction is used to divide -9 by 4, the result is -2 with a remainder of -1. If the <code>SAR</code> instruction is used to shift -9 right by two bits, the result is -3 and the “remainder” is +3; however, the <code>SAR</code> instruction stores only the most significant bit of the remainder (in the <code>CF</code> flag).</p>
<p>The <code>OF</code> flag is affected only on 1-bit shifts. For left shifts, the <code>OF</code> flag is set to 0 if the most-significant bit of the result is the same as the <code>CF</code> flag (that is, the top two bits of the original operand were the same); otherwise, it is set to 1. For the <code>SAR</code> instruction, the <code>OF</code> flag is cleared for all 1-bit shifts. For the <code>SHR</code> instruction, the <code>OF</code> flag is set to the most-significant bit of the original operand.</p>
<p>In 64-bit mode, the instruction’s default operation size is 32 bits and the mask width for <code>CL</code> is 5 bits. Using a <code>REX</code> prefix in the form of <code>REX.R</code> permits access to additional registers (<code>R8</code>-<code>R15</code>). Using a <code>REX</code> prefix in the form of <code>REX.W</code> promotes operation to 64-bits and sets the mask width for <code>CL</code> to 6 bits. See the summary chart at the beginning of this section for encoding data and limits.</p>
<h2 id="operation-19"><a class="header" href="#operation-19">Operation</a></h2>
<p><code>DEST</code>: first operand<br />
<code>COUNT</code>: second operand<br />
<code>countMASK</code>: <code>0b00111111</code> (= 63) for 64-bit operations, <code>0b00011111</code> (= 31) otherwise</p>
<h3 id="salshl-1"><a class="header" href="#salshl-1"><code>SAL</code>|<code>SHL</code></a></h3>
<pre><code class="language-rust ignore">tempCOUNT = COUNT &amp; countMASK;
while tempCOUNT != 0 {
    CF = MSB(DEST);
    DEST = DEST * 2;
    tempCOUNT = tempCOUNT - 1;
}

// determine overflow
if COUNT &amp; countMASK == 1 {
    OF = MSB(DEST) ^ CF;
} else if COUNT &amp; countMASK == 0 {
    // all flags unchanged
} else {
    // COUNT not 1 or 0
    // OF undefined
}
</code></pre>
<h3 id="sar-1"><a class="header" href="#sar-1"><code>SAR</code></a></h3>
<pre><code class="language-rust ignore">tempCOUNT = COUNT &amp; countMASK;
while tempCOUNT != 0 {
    CF = LSB(DEST);
    DEST = DEST / 2; // signed divide, rounding toward negative infinity
    tempCOUNT = tempCOUNT - 1;
}

// determine overflow
if COUNT &amp; countMASK == 1 {
    OF = 0;
} else if COUNT &amp; countMASK == 0 {
    // all flags unchanged
} else {
    // COUNT not 1 or 0
    // OF undefined
}
</code></pre>
<h3 id="shr-1"><a class="header" href="#shr-1"><code>SHR</code></a></h3>
<pre><code class="language-rust ignore">tempCOUNT = COUNT &amp; countMASK;
while tempCOUNT != 0 {
    CF = LSB(DEST);
    DEST = DEST / 2; // unsigned divide
    tempCOUNT = tempCOUNT - 1;
}

// determine overflow
if COUNT &amp; countMASK == 1 {
    OF = MSB(tempDEST);
} else if COUNT &amp; countMASK == 0 {
    // all flags unchanged
} else {
    // COUNT not 1 or 0
    // OF undefined
}
</code></pre>
<h2 id="flags-affected-18"><a class="header" href="#flags-affected-18">Flags Affected</a></h2>
<p>The <code>CF</code> flag contains the value of the last bit shifted out of the destination operand; it is undefined for <code>SHL</code> and <code>SHR</code> instructions where the count is greater than or equal to the size (in bits) of the destination operand. The <code>OF</code> flag is affected only for 1-bit shifts (see <a href="instructions/shift-and-rotate-instructions/sal,sar,shl,shr.html#description">Description</a> below); otherwise, it is undefined. The <code>SF</code>, <code>ZF</code>, and <code>PF</code> flags are set according to the result. If the count is 0, the flags are not affected. For a non-zero count, the <code>AF</code> flag is undefined.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="bit-and-byte-instructions-1"><a class="header" href="#bit-and-byte-instructions-1">Bit and Byte Instructions</a></h1>
<!-- ANCHOR: table -->
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Mnemonic</th><th style="text-align: left">Summary</th></tr></thead><tbody>
<tr><td style="text-align: left"><a href="instructions/bit-and-byte-instructions/test.html"><code>TEST</code></a></td><td style="text-align: left">Logical Compare</td></tr>
</tbody></table>
</div><!-- ANCHOR_END: table -->
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="test"><a class="header" href="#test"><code>TEST</code></a></h1>
<p>Logical Compare</p>
<p>The same operation as <a href="instructions/bit-and-byte-instructions/../logical-instructions/and.html"><code>AND</code></a>, but do not save the result in a register, only keep the flags.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Instruction</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>TEST r/m8, imm8</code></td><td style="text-align: left">AND <code>imm8</code> with <code>r/m8</code>; only set Flags</td></tr>
<tr><td style="text-align: left"><code>TEST r/m16, imm16</code></td><td style="text-align: left">AND <code>imm16</code> with <code>r/m16</code>; only set Flags</td></tr>
<tr><td style="text-align: left"><code>TEST r/m32, imm32</code></td><td style="text-align: left">AND <code>imm32</code> with <code>r/m32</code>; only set Flags</td></tr>
<tr><td style="text-align: left"><code>TEST r/m64, imm32</code></td><td style="text-align: left">AND sign-extended <code>imm32</code> with <code>r/m64</code>; only set Flags</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>TEST r/m8, r8</code></td><td style="text-align: left">AND <code>r8</code> with <code>r/m8</code>; only set Flags</td></tr>
<tr><td style="text-align: left"><code>TEST r/m16, r16</code></td><td style="text-align: left">AND <code>r16</code> with <code>r/m16</code>; only set Flags</td></tr>
<tr><td style="text-align: left"><code>TEST r/m32, r32</code></td><td style="text-align: left">AND <code>r32</code> with <code>r/m32</code>; only set Flags</td></tr>
<tr><td style="text-align: left"><code>TEST r/m64, r64</code></td><td style="text-align: left">AND <code>r64</code> with <code>r/m64</code>; only set Flags</td></tr>
</tbody></table>
</div>
<h2 id="description-19"><a class="header" href="#description-19">Description</a></h2>
<p>Computes the bit-wise logical <code>AND</code> of first operand (source 1 operand) and the second operand (source 2 operand) and sets the <code>SF</code>, <code>ZF</code>, and <code>PF</code> status flags according to the result. The result is then discarded.</p>
<p>In 64-bit mode, using a <code>REX</code> prefix in the form of <code>REX.R</code> permits access to additional registers (<code>R8</code>-<code>R15</code>). Using a <code>REX</code> prefix in the form of <code>REX.W</code> promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.</p>
<h2 id="operation-20"><a class="header" href="#operation-20">Operation</a></h2>
<p><code>SRC1</code>: first operand<br />
<code>SRC2</code>: second operand</p>
<pre><code class="language-rust ignore">TEMP = SRC1 &amp; SRC2;
SF = MSB(TEMP);

if TEMP == 0 {
    ZF = 1;
} else {
    ZF = 0;
}

PF = BitwiseXNOR(TEMP[0..=7]);
CF = 0;
OF = 0;
// AF is undefined
</code></pre>
<h2 id="flags-affected-19"><a class="header" href="#flags-affected-19">Flags Affected</a></h2>
<p>The <code>OF</code> and <code>CF</code> flags are set to 0. The <code>SF</code>, <code>ZF</code>, and <code>PF</code> flags are set according to the result (see the <a href="instructions/bit-and-byte-instructions/test.html#operation">Operation section</a> above). The state of the <code>AF</code> flag is undefined.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="control-transfer-instructions-1"><a class="header" href="#control-transfer-instructions-1">Control Transfer Instructions</a></h1>
<!-- ANCHOR: table -->
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Mnemonic</th><th style="text-align: left">Summary</th></tr></thead><tbody>
<tr><td style="text-align: left"><a href="instructions/control-transfer-instructions/jmp.html"><code>JMP</code></a></td><td style="text-align: left">Jump</td></tr>
<tr><td style="text-align: left"><a href="instructions/control-transfer-instructions/jcc.html"><code>Jcc</code></a></td><td style="text-align: left">Jump if <code>cc</code></td></tr>
<tr><td style="text-align: left"><a href="instructions/control-transfer-instructions/call.html"><code>CALL</code></a></td><td style="text-align: left">Call Procedure</td></tr>
<tr><td style="text-align: left"><a href="instructions/control-transfer-instructions/ret.html"><code>RET</code></a></td><td style="text-align: left">Return</td></tr>
</tbody></table>
</div><!-- ANCHOR_END: table -->
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="jmp"><a class="header" href="#jmp"><code>JMP</code></a></h1>
<p>Jump</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Instruction</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>JMP rel8</code></td><td style="text-align: left">Jump short, <code>RIP</code> = <code>RIP</code> + 8-bit displacement sign-extended to 64-bits</td></tr>
<tr><td style="text-align: left"><code>JMP rel16</code></td><td style="text-align: left">Jump near, relative, displacement relative to next instruction; Not supported in 64-bit mode</td></tr>
<tr><td style="text-align: left"><code>JMP rel32</code></td><td style="text-align: left">Jump near, realtive, <code>RIP</code> = <code>RIP</code> + 32-bit displacement sign-extended to 64-bits</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>JMP r/m16</code></td><td style="text-align: left">Jump near, absolute indirect, address = zer-extended <code>r/m16</code>; Not supported in 64-bit mode</td></tr>
<tr><td style="text-align: left"><code>JMP r/m32</code></td><td style="text-align: left">Jump near, absolute indirect, address given in <code>r/m32</code>; Not supported in 64-bit mode</td></tr>
<tr><td style="text-align: left"><code>JMP r/m64</code></td><td style="text-align: left">Jump near, absolute indirect, <code>RIP</code> = 64-bit offset from register or memory</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>JMP ptr16:16</code></td><td style="text-align: left">Jump far, absolute, address given in operand</td></tr>
<tr><td style="text-align: left"><code>JMP ptr16:32</code></td><td style="text-align: left">Jump far, absolute, address given in operand</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>JMP m16:16</code></td><td style="text-align: left">Jump far, absolute indirect, address given in operand</td></tr>
<tr><td style="text-align: left"><code>JMP m16:32</code></td><td style="text-align: left">Jump far, absolute indirect, address given in operand</td></tr>
<tr><td style="text-align: left"><code>JMP m16:64</code></td><td style="text-align: left">Jump far, absolute indirect, address given in operand</td></tr>
</tbody></table>
</div>
<h2 id="description-20"><a class="header" href="#description-20">Description</a></h2>
<p>Transfers program control to a different point in the instruction stream without recording return information. The destination (target) operand specifies the address of the instruction being jumped to. This operand can be an immediate value, a general-purpose register, or a memory location.</p>
<p>This instruction can be used to execute four different types of jumps:</p>
<ul>
<li><strong>Near jump</strong><br />
A jump to an instruction within the current code segment (the segment currently pointed to by the <code>CS</code> register), sometimes referred to as an intrasegment jump.</li>
<li><strong>Short jump</strong><br />
A near jump where the jump range is limited to –128 to +127 from the current <code>EIP</code> value.</li>
<li><strong>Far jump</strong><br />
A jump to an instruction located in a different segment than the current code segment but at the same privilege level, sometimes referred to as an intersegment jump.</li>
<li><strong>Task switch</strong><br />
A jump to an instruction located in a different task.
A task switch can only be executed in protected mode (see Chapter 7, in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A, for information on performing task switches with the JMP instruction).</li>
</ul>
<h3 id="near-and-short-jumps"><a class="header" href="#near-and-short-jumps">Near and Short Jumps</a></h3>
<p>When executing a near jump, the processor jumps to the address (within the current code segment) that is specified with the target operand. The target operand specifies either an absolute offset (that is an offset from the base of the code segment) or a relative offset (a signed displacement relative to the current value of the instruction pointer in the <code>EIP</code> register). A near jump to a relative offset of 8-bits (<code>rel8</code>) is referred to as a short jump. The <code>CS</code> register is not changed on near and short jumps.</p>
<p>An absolute offset is specified indirectly in a general-purpose register or a memory location (<code>r/m16</code> or <code>r/m32</code>). The operand-size attribute determines the size of the target operand (16 or 32 bits). Absolute offsets are loaded directly into the <code>EIP</code> register. If the operand-size attribute is 16, the upper two bytes of the <code>EIP</code> register are cleared, resulting in a maximum instruction pointer size of 16 bits.</p>
<p>A relative offset (<code>rel8</code>, <code>rel16</code>, or <code>rel32</code>) is generally specified as a label in assembly code, but at the machine code level, it is encoded as a signed 8-, 16-, or 32-bit immediate value. This value is added to the value in the <code>EIP</code> register. (Here, the <code>EIP</code> register contains the address of the instruction following the <code>JMP</code> instruction). When using relative offsets, the opcode (for short vs. near jumps) and the operand-size attribute (for near relative jumps) determines the size of the target operand (8, 16, or 32 bits).</p>
<h3 id="far-jumps-in-real-address-or-virtual-8086-mode"><a class="header" href="#far-jumps-in-real-address-or-virtual-8086-mode">Far Jumps in Real-Address or Virtual-8086 Mode</a></h3>
<p>When executing a far jump in real-address or virtual-8086 mode, the processor jumps to the code segment and offset specified with the target operand. Here the target operand specifies an absolute far address either directly with a pointer (<code>ptr16:16</code> or <code>ptr16:32</code>) or indirectly with a memory location (<code>m16:16</code> or <code>m16:32</code>). With the pointer method, the segment and address of the called procedure is encoded in the instruction, using a 4-byte (16-bit operand size) or 6-byte (32-bit operand size) far address immediate. With the indirect method, the target operand specifies a memory location that contains a 4-byte (16-bit operand size) or 6-byte (32-bit operand size) far address. The far address is loaded directly into the <code>CS</code> and <code>EIP</code> registers. If the operand-size attribute is 16, the upper two bytes of the <code>EIP</code> register are cleared.</p>
<h3 id="far-jumps-in-protected-mode"><a class="header" href="#far-jumps-in-protected-mode">Far Jumps in Protected Mode</a></h3>
<p>When the processor is operating in protected mode, the <code>JMP</code> instruction can be used to perform the following three types of far jumps:</p>
<ul>
<li>A far jump to a conforming or non-conforming code segment.</li>
<li>A far jump through a call gate.</li>
<li>A task switch.
(The <code>JMP</code> instruction cannot be used to perform inter-privilege-level far jumps.)</li>
</ul>
<p>In protected mode, the processor always uses the segment selector part of the far address to access the corresponding descriptor in the <code>GDT</code> or <code>LDT</code>. The descriptor type (code segment, call gate, task gate, or <code>TSS</code>) and access rights determine the type of jump to be performed.</p>
<p>If the selected descriptor is for a code segment, a far jump to a code segment at the same privilege level is performed. (If the selected code segment is at a different privilege level and the code segment is non-conforming, a general-protection exception is generated.) A far jump to the same privilege level in protected mode is very similar to one carried out in real-address or virtual-8086 mode. The target operand specifies an absolute far address either directly with a pointer (<code>ptr16:16</code> or <code>ptr16:32</code>) or indirectly with a memory location (<code>m16:16</code> or <code>m16:32</code>). The operand-size attribute determines the size of the offset (16 or 32 bits) in the far address. The new code segment selector and its descriptor are loaded into <code>CS</code> register, and the offset from the instruction is loaded into the <code>EIP</code> register. Note that a call gate (described in the next paragraph) can also be used to perform far call to a code segment at the same privilege level. Using this mechanism provides an extra level of indirection and is the preferred method of making jumps between 16-bit and 32-bit code segments.</p>
<p>When executing a far jump through a call gate, the segment selector specified by the target operand identifies the call gate. (The offset part of the target operand is ignored.) The processor then jumps to the code segment specified in the call gate descriptor and begins executing the instruction at the offset specified in the call gate. No stack switch occurs. Here again, the target operand can specify the far address of the call gate either directly with a pointer (<code>ptr16:16</code> or <code>ptr16:32</code>) or indirectly with a memory location (<code>m16:16</code> or <code>m16:32</code>).</p>
<p>Executing a task switch with the <code>JMP</code> instruction is somewhat similar to executing a jump through a call gate. Here the target operand specifies the segment selector of the task gate for the task being switched to (and the offset part of the target operand is ignored). The task gate in turn points to the <code>TSS</code> for the task, which contains the segment selectors for the task’s code and stack segments. The <code>TSS</code> also contains the <code>EIP</code> value for the next instruction that was to be executed before the task was suspended. This instruction pointer value is loaded into the <code>EIP</code> register so that the task begins executing again at this next instruction.</p>
<p>The <code>JMP</code> instruction can also specify the segment selector of the <code>TSS</code> directly, which eliminates the indirection of the task gate. See Chapter 7 in Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A, for detailed information on the mechanics of a task switch.</p>
<p>Note that when you execute at task switch with a <code>JMP</code> instruction, the nested task flag (<code>NT</code>) is not set in the <code>EFLAGS</code> register and the new <code>TSS</code>’s previous task link field is not loaded with the old task’s <code>TSS</code> selector. A return to the previous task can thus not be carried out by executing the <code>IRET</code> instruction. Switching tasks with the <code>JMP</code> instruction differs in this regard from the <code>CALL</code> instruction which does set the <code>NT</code> flag and save the previous task link information, allowing a return to the calling task with an <code>IRET</code> instruction.</p>
<p>Refer to Chapter 6, “Procedure Calls, Interrupts, and Exceptions” and Chapter 18, “Control-Flow Enforcement
Technology (CET)” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1 for <code>CET</code>
details.</p>
<h3 id="in-64-bit-mode"><a class="header" href="#in-64-bit-mode">In 64-Bit Mode</a></h3>
<p>The instruction’s operation size is fixed at 64 bits. If a selector points to a gate, then <code>RIP</code> equals the 64-bit displacement taken from gate; else <code>RIP</code> equals the zero-extended offset from the far pointer referenced in the instruction.</p>
<p>See the summary chart at the beginning of this section for encoding data and limits.</p>
<h3 id="instruction-ordering"><a class="header" href="#instruction-ordering">Instruction ordering</a></h3>
<p>Instructions following a far jump may be fetched from memory before earlier instructions complete execution, but they will not execute (even speculatively) until all instructions prior to the far jump have completed execution (the later instructions may execute before data stored by the earlier instructions have become globally visible).</p>
<p>Certain situations may lead to the next sequential instruction after a near indirect <code>JMP</code> being speculatively executed. If software needs to prevent this (e.g., in order to prevent a speculative execution side channel), then an <code>INT3</code> or <code>LFENCE</code> instruction opcode can be placed after the near indirect <code>JMP</code> in order to block speculative execution.</p>
<h2 id="operation-21"><a class="header" href="#operation-21">Operation</a></h2>
<pre><code class="language-rust ignore">if /* near jump */ {
    if /* 64-bit Mode */ {
        if /* near relative jump */ {
            // RIP is instruction following JMP instruction
            tempRIP = RIP + DEST;
        } else {
            // near absolute jump
            tempRIP = DEST;
        }
    } else {
        if /* near relative jump */ {
            // EIP is instruction following JMP instruction
            tempEIP = EIP + DEST;
        } else {
            // near absolute jump
            tempEIP = DEST;
        }
    }
    if (IA32_EFER.LMA == 0 || target mode == Compatibility mode)
            &amp;&amp; /* tempEIP outside code segment limit */ {
        #GP(0);
    }
    if /* 64-bit mode and tempRIP is not canonical */ {
        #GP(0);
    }
    if OperandSize == 32 {
        EIP = tempEIP;
    } else {
        if OperandSize == 16 {
            EIP = tempEIP &amp; 0x0000_FFFF;
        } else {
            // OperandSize == 64
            RIP = tempRIP;
        }
    }
    if /* JMP near indirect, absolute indirect */ {
        if EndbranchEnabledAndNotSuppressed(CPL) {
            if CPL == 3 {
                if /* no 3EH prefix */ || IA32_U_CET.NO_TRACK_EN == 0 {
                    IA32_U_CET.TRACKER = WAIT_FOR_ENDBRANCH;
                }
            } else {
                if /* no 3EH prefix */ || IA32_S_CET.NO_TRACK_EN == 0 {
                    IA32_S_CET.TRACKER = WAIT_FOR_ENDBRANCH;
                }
            }
        }
    }
}

if /* far jump */ &amp;&amp; (PE == 0 || (PE == 1 &amp;&amp; VM == 1)) {
    // real-address or virtual-8086 mode
    tempEIP = DEST(Offset); // DEST is ptr16:32 or [m16:32]
    if /* tempEIP is beyond code segment limit */ {
        #GP(0);
    }
    CS = DEST(segment selector); // DEST is ptr16:32 or [m16:32]
    if OperandSize == 32 {
        EIP = tempEIP; // DEST is ptr16:32 or [m16:32]
    } else {
        // OperandSize == 16
        EIP = tempEIP &amp; 0x0000_FFFF; // clear upper 16 bits
    }
}

if /* far jump */ &amp;&amp; PE == 1 &amp;&amp; VM == 0 {
    // IA-32e mode or protected mode, not virtual-8086 mode
    if /* effective address in the CS, DS, ES, FS, GS, or SS segment is illegal
            or segment selector in target operand NULL */ {
        #GP(0);
    }
    if /* segment selector index not within descriptor table limits */ {
        #GP(new selector);
    }
    /* read type and access rights of segment descriptor; */
    if IA32_EFER.LMA == 0 {
        if /* segment type is not a conforming or nonconforming code
                segment, call gate, task gate, or TSS */ {
            #GP(segment selector);
        }
    } else {
        if /* segment type is not a conforming or nonconforming code segment
                call gate */ {
            #GP(segment selector);
        }
    }
    /* Depending on type and access rights: */
        goto 'CONFORMING_CODE_SEGMENT;
        goto 'NONCONFORMING_CODE_SEGMENT;
        goto 'CALL_GATE;
        goto 'TASK_GATE;
        goto 'TASK_STATE_SEGMENT;
} else {
    #GP(segment selector);
}

'CONFORMING_CODE_SEGMENT {
    if L-Bit == 1 &amp;&amp; D-BIT == 1 &amp;&amp; IA32_EFER.LMA == 1 {
        #GP(new code segment selector);
    }
    if DPL &gt; CPL {
        #GP(segment selector);
    }
    if /* segment not present */ {
        #NP(segment selector);
    }
    tempEIP = DEST(Offset);
    if OperandSize == 16 {
        tempEIP = tempEIP &amp; 0x0000_FFFF;
    }
    if (IA32_EFER.LMA == 0 || target mode == Compatibility mode)
            &amp;&amp; /* tempEIP outside code segment limit */ {
        #GP(0);
    }
    if /* tempEIP is non-canonical */ {
        #GP(0);
    }
    if ShadowStackEnabled(CPL) {
        if (IA32_EFER.LMA &amp; DEST(segment selector).L) == 0 {
            // if target is legacy or compatibility mode then the SSP must be in low 4GB
            if SSP &amp; 0xFFFF_FFFF_0000_0000 != 0
                #GP(0);
            FI;
        }
    }
    CS = DEST[segment selector]; // segment descriptor information also loaded
    CS(RPL) = CPL
    EIP = tempEIP;
    if EndbranchEnabled(CPL) {
        if CPL = 3 {
            IA32_U_CET.TRACKER = WAIT_FOR_ENDBRANCH;
            IA32_U_CET.SUPPRESS = 0;
        } else {
            IA32_S_CET.TRACKER = WAIT_FOR_ENDBRANCH;
            IA32_S_CET.SUPPRESS = 0;
        }
    }
}

'NONCONFORMING_CODE_SEGMENT {
    if L-Bit == 1 &amp;&amp; D-BIT == 1 &amp;&amp; IA32_EFER.LMA == 1 {
        #GP(new code segment selector);
    }
    if (RPL &gt; CPL) || (DPL != CPL) {
        #GP(code segment selector);
    }
    if /* segment not present */ {
        #NP(segment selector);
    }
    tempEIP = DEST(Offset);
    if OperandSize == 16 {
        tempEIP = tempEIP &amp; 0x0000_FFFF;
    }
    if (IA32_EFER.LMA == 0 || target mode == Compatibility mode)
            &amp;&amp; /* tempEIP outside code segment limit */ {
        #GP(0);
    }
    if /* tempEIP is non-canonical */ {
        #GP(0);
    }
    if ShadowStackEnabled(CPL) {
        if (IA32_EFER.LMA &amp; DEST(segment selector).L) == 0 {
            // if target is legacy or compatibility mode then the SSP must be in low 4GB
            if (SSP &amp; 0xFFFF_FFFF_0000_0000 != 0) {
                #GP(0);
            }
        }
    }
    CS = DEST[segment selector]; // segment descriptor information also loaded
    CS(RPL) = CPL;
    EIP = tempEIP;
    if EndbranchEnabled(CPL) {
        if CPL == 3 {
            IA32_U_CET.TRACKER = WAIT_FOR_ENDBRANCH;
            IA32_U_CET.SUPPRESS = 0;
        } else {
            IA32_S_CET.TRACKER = WAIT_FOR_ENDBRANCH;
            IA32_S_CET.SUPPRESS = 0;
        }
    }
}

'CALL_GATE {
    if call gate DPL &lt; CPL
            || call gate DPL &lt; call gate segment-selector RPL {
        #GP(call gate selector);
    }
    if /* call gate not present */ {
        #NP(call gate selector);
    }
    if /* call gate code-segment selector is NULL */ {
        #GP(0);
    }
    if /* call gate code-segment selector index outside descriptor table limits */ {
        #GP(code segment selector);
    }
    /* Read code segment descriptor; */
    if /* code-segment segment descriptor does not indicate a code segment */
            || (/* code-segment segment descriptor is conforming */ &amp;&amp; DPL &gt; CPL)
            || (/* code-segment segment descriptor is non-conforming */ &amp;&amp; DPL != CPL)
        #GP(code segment selector);
    }
    if IA32_EFER.LMA == 1 &amp;&amp; (/* code-segment descriptor is not a 64-bit code segment */
            || /* code-segment segment descriptor has both L-Bit and D-bit set */) {
        #GP(code segment selector);
    }
    if /* code segment is not present */ {
        #NP(code-segment selector);
    }
    tempEIP = DEST(Offset);
    if GateSize == 16 {
        tempEIP = tempEIP &amp; 0x0000_FFFF;
    }
    if (IA32_EFER.LMA == 0 || target mode == Compatibility mode)
            &amp;&amp; /* tempEIP outside code segment limit */ {
        #GP(0);
    }
    CS = DEST[SegmentSelector]; // segment descriptor information also loaded
    CS(RPL) = CPL;
    EIP = tempEIP;
    if EndbranchEnabled(CPL) {
        if CPL == 3 {
            IA32_U_CET.TRACKER = WAIT_FOR_ENDBRANCH;
            IA32_U_CET.SUPPRESS = 0;
        } else {
            IA32_S_CET.TRACKER = WAIT_FOR_ENDBRANCH;
            IA32_S_CET.SUPPRESS = 0;
        }
    }
}

'TASK_GATE {
    if task gate DPL &lt; CPL
            || task gate DPL &lt; task gate segment-selector RPL {
        #GP(task gate selector);
    }
    if /* task gate not present */ {
        #NP(gate selector);
    }
    /* Read the TSS segment selector in the task-gate descriptor; */
    if /* TSS segment selector local/global bit is set to local */
            || /* index not within GDT limits */
            || /* descriptor is not a TSS segment */
            || /* TSS descriptor specifies that the TSS is busy */ {
        #GP(TSS selector);
    }
    if /* TSS not present */ {
        #NP(TSS selector);
    }
    SWITCH-TASKS to TSS;
    if /* EIP not within code segment limit */ {
        #GP(0);
    }
}

'TASK_STATE_SEGMENT {
    if TSS DPL &lt; CPL
            || TSS DPL &lt; TSS segment-selector RPL
            || /* TSS descriptor indicates TSS not available */ {
        #GP(TSS selector);
    }
    if /* TSS is not present */ {
        #NP(TSS selector);
    }
    SWITCH-TASKS to TSS;
    if /* EIP not within code segment limit */
        #GP(0);
    }
}
</code></pre>
<h2 id="flags-affected-20"><a class="header" href="#flags-affected-20">Flags Affected</a></h2>
<p>All flags are affected if a task switch occurs; no flags are affected if a task switch does not occur.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="jcc"><a class="header" href="#jcc"><code>Jcc</code></a></h1>
<p>Jump if Condition Is Met</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Instruction</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>Jcc rel8</code></td><td style="text-align: left">Jump short if <code>cc</code></td></tr>
<tr><td style="text-align: left"><code>Jcc rel16</code></td><td style="text-align: left">Jump near if <code>cc</code>; Not supported in 64-bit mode</td></tr>
<tr><td style="text-align: left"><code>Jcc rel32</code></td><td style="text-align: left">Jump near if <code>cc</code></td></tr>
</tbody></table>
</div>
<h2 id="description-21"><a class="header" href="#description-21">Description</a></h2>
<p>Checks the state of one or more of the status flags in the <code>EFLAGS</code> register (<code>CF</code>, <code>OF</code>, <code>PF</code>, <code>SF</code>, and <code>ZF</code>) and, if the flags are in the specified state (condition), performs a jump to the target instruction specified by the destination operand. A condition code (<code>cc</code>) is associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, the jump is not performed and execution continues with the instruction following the <code>Jcc</code> instruction.</p>
<p>The target instruction is specified with a relative offset (a signed offset relative to the current value of the instruction pointer in the <code>EIP</code> register). A relative offset (<code>rel8</code>, <code>rel16</code>, or <code>rel32</code>) is generally specified as a label in assembly code, but at the machine code level, it is encoded as a signed, 8-bit or 32-bit immediate value, which is added to the instruction pointer. Instruction coding is most efficient for offsets of –128 to +127. If the operand-size attribute is 16, the upper two bytes of the <code>EIP</code> register are cleared, resulting in a maximum instruction pointer size of 16 bits.</p>
<p>The conditions for each <code>Jcc</code> mnemonic are given in the “Description” column of the table on the preceding page. The terms “less” and “greater” are used for comparisons of signed integers and the terms “above” and “below” are used for unsigned integers.</p>
<p>Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are defined for some opcodes. For example, the <code>JA</code> (jump if above) instruction and the <code>JNBE</code> (jump if not below or equal) instruction are alternate mnemonics for the opcode <code>0x77</code>.</p>
<p>The <code>Jcc</code> instruction does not support far jumps (jumps to other code segments). When the target for the conditional jump is in a different segment, use the opposite condition from the condition being tested for the <code>Jcc</code> instruction, and then access the target with an unconditional far jump (<code>JMP</code> instruction) to the other segment. For example, the following conditional far jump is illegal:</p>
<pre><code class="language-x86asm">jz FARLABEL
</code></pre>
<p>To accomplish this far jump, use the following two instructions:</p>
<pre><code class="language-x86asm">jnz BEYOND
jmp FARLABEL
BEYOND:
</code></pre>
<p>The <code>JRCXZ</code>, <code>JECXZ</code> and <code>JCXZ</code> instructions differ from other <code>Jcc</code> instructions because they do not check status flags. Instead, they check <code>RCX</code>, <code>ECX</code> or <code>CX</code> for 0. The register checked is determined by the address-size attribute. These instructions are useful when used at the beginning of a loop that terminates with a conditional loop instruction (such as <code>LOOPNE</code>). They can be used to prevent an instruction sequence from entering a loop when <code>RCX</code>, <code>ECX</code> or <code>CX</code> is 0. This would cause the loop to execute 264, 232 or 64K times (not zero times).</p>
<p>All conditional jumps are converted to code fetches of one or two cache lines, regardless of jump address or cacheability.</p>
<p>In 64-bit mode, operand size is fixed at 64 bits. <code>JMP</code> Short is <code>RIP</code> = <code>RIP</code> + 8-bit offset sign extended to 64 bits. <code>JMP</code> Near is <code>RIP</code> = <code>RIP</code> + 32-bit offset sign extended to 64 bits.</p>
<h2 id="operation-22"><a class="header" href="#operation-22">Operation</a></h2>
<pre><code class="language-rust ignore">if condition {
    tempEIP = EIP + SignExtend(DEST);
    if OperandSize == 16 {
        tempEIP = tempEIP &amp;&amp; 0x0000_FFFF;
    }
    if /* tempEIP is not within code segment limit */ {
        #GP(0);
    } else {
        EIP = tempEIP;
    }
}
</code></pre>
<h2 id="flags-affected-21"><a class="header" href="#flags-affected-21">Flags Affected</a></h2>
<p>None.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="call"><a class="header" href="#call"><code>CALL</code></a></h1>
<p>Call Procedure</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Instruction</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>CALL rel16</code></td><td style="text-align: left">Call near, relative, displacement realtive to next instruction</td></tr>
<tr><td style="text-align: left"><code>CALL rel32</code></td><td style="text-align: left">Call near, realtive, displacement relative to next instruction; 32-bit displacement sign extended to 64-bits in 64-bit mode</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>CALL r/m16</code></td><td style="text-align: left">Call near, absolute indirect, address given in <code>r/m16</code></td></tr>
<tr><td style="text-align: left"><code>CALL r/m32</code></td><td style="text-align: left">Call near, absolute indirect, address given in <code>r/m32</code></td></tr>
<tr><td style="text-align: left"><code>CALL r/m64</code></td><td style="text-align: left">Call near, absolute indirect, address given in <code>r/m64</code></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>CALL ptr16:16</code></td><td style="text-align: left">Call far, absolute, address given in operand</td></tr>
<tr><td style="text-align: left"><code>CALL ptr16:32</code></td><td style="text-align: left">Call far, absolute, address given in operand</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>CALL m16:16</code></td><td style="text-align: left">Call far, absolute indirect address given in <code>m16:16</code>; In 32-bit mode: If selector points to a gater, then <code>RIP</code> = 32-bit zero-extended displacement taken from gate; else <code>RIP</code> = zero-extended 16-bit offset from far pointer referenced in the instruction</td></tr>
<tr><td style="text-align: left"><code>CALL m16:32</code></td><td style="text-align: left">In 64-bit mode: If selector points to a gate, then <code>RIP</code> = 64-bit displacement taken from gate; else <code>RIP</code> = zero-extended 32-bit offset from far pointer referenced in the instruction</td></tr>
<tr><td style="text-align: left"><code>CALL m16:64</code></td><td style="text-align: left">In 64-bit mode: If selector points to a gate, then <code>RIP</code> = 64-bit displacement taken from gate; else <code>RIP</code> = 64-bit offset from far pointer referenced in the instruction</td></tr>
</tbody></table>
</div>
<h2 id="description-22"><a class="header" href="#description-22">Description</a></h2>
<p>Saves procedure linking information on the stack and branches to the called procedure specified using the target operand. The target operand specifies the address of the first instruction in the called procedure. The operand can be an immediate value, a general-purpose register, or a memory location.</p>
<p>This instruction can be used to execute four types of calls:</p>
<ul>
<li><strong>Near Call</strong><br />
A call to a procedure in the current code segment (the segment currently pointed to by the <code>CS</code> register), sometimes referred to as an intra-segment call.</li>
<li><strong>Far Call</strong><br />
A call to a procedure located in a different segment than the current code segment, sometimes referred to as an inter-segment call.</li>
<li><strong>Inter-privilege-level far call</strong><br />
A far call to a procedure in a segment at a different privilege level than that of the currently executing program or procedure.</li>
<li><strong>Task switch</strong><br />
A call to a procedure located in a different task.
The latter two call types (inter-privilege-level call and task switch) can only be executed in protected mode. See “Calling Procedures Using Call and RET” in Chapter 6 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for additional information on near, far, and inter-privilege-level calls. See Chapter 7, “Task Management,” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A, for information on performing task switches with the <code>CALL</code> instruction.</li>
</ul>
<h3 id="near-call"><a class="header" href="#near-call">Near Call</a></h3>
<p>When executing a near call, the processor pushes the value of the <code>EIP</code> register (which contains the offset of the instruction following the <code>CALL</code> instruction) on the stack (for use later as a return-instruction pointer). The processor then branches to the address in the current code segment specified by the target operand. The target operand specifies either an absolute offset in the code segment (an offset from the base of the code segment) or a relative offset (a signed displacement relative to the current value of the instruction pointer in the <code>EIP</code> register; this value points to the instruction following the <code>CALL</code> instruction). The <code>CS</code> register is not changed on near calls.</p>
<p>For a near call absolute, an absolute offset is specified indirectly in a general-purpose register or a memory location (<code>r/m16</code>, <code>r/m32</code>, or <code>r/m64</code>). The operand-size attribute determines the size of the target operand (16, 32 or 64 bits). When in 64-bit mode, the operand size for near call (and all near branches) is forced to 64-bits. Absolute offsets are loaded directly into the <code>EIP</code>(<code>RIP</code>) register. If the operand size attribute is 16, the upper two bytes of the <code>EIP</code> register are cleared, resulting in a maximum instruction pointer size of 16 bits. When accessing an absolute offset indirectly using the stack pointer [<code>ESP</code>] as the base register, the base value used is the value of the <code>ESP</code> before the instruction executes.</p>
<p>A relative offset (<code>rel16</code> or <code>rel32</code>) is generally specified as a label in assembly code. But at the machine code level, it is encoded as a signed, 16- or 32-bit immediate value. This value is added to the value in the <code>EIP</code>(<code>RIP</code>) register. In 64-bit mode the relative offset is always a 32-bit immediate value which is sign extended to 64-bits before it is added to the value in the <code>RIP</code> register for the target calculation. As with absolute offsets, the operand-size attribute determines the size of the target operand (16, 32, or 64 bits). In 64-bit mode the target operand will always be 64-bits because the operand size is forced to 64-bits for near branches.</p>
<h3 id="far-calls-in-real-address-or-virtual-8086-mode"><a class="header" href="#far-calls-in-real-address-or-virtual-8086-mode">Far Calls in Real-Address or Virtual-8086 Mode</a></h3>
<p>When executing a far call in realaddress or virtual-8086 mode, the processor pushes the current value of both the <code>CS</code> and <code>EIP</code> registers on the stack for use as a return-instruction pointer. The processor then performs a “far branch” to the code segment and offset specified with the target operand for the called procedure. The target operand specifies an absolute far address either directly with a pointer (<code>ptr16:16</code> or <code>ptr16:32</code>) or indirectly with a memory location (<code>m16:16</code> or <code>m16:32</code>). With the pointer method, the segment and offset of the called procedure is encoded in the instruction using a 4-byte (16-bit operand size) or 6-byte (32-bit operand size) far address immediate. With the indirect method, the target operand specifies a memory location that contains a 4-byte (16-bit operand size) or 6-byte (32-bit operand size) far address. The operand-size attribute determines the size of the offset (16 or 32 bits) in the far address. The far address is loaded directly into the <code>CS</code> and <code>EIP</code> registers. If the operand-size attribute is 16, the upper two bytes of the <code>EIP</code> register are cleared.</p>
<h3 id="far-calls-in-protected-mode"><a class="header" href="#far-calls-in-protected-mode">Far Calls in Protected Mode</a></h3>
<p>When the processor is operating in protected mode, the <code>CALL</code> instruction can be used to perform the following types of far calls:</p>
<ul>
<li>Far call to the same privilege level</li>
<li>Far call to a different privilege level (inter-privilege level call)</li>
<li>Task switch (far call to another task)
In protected mode, the processor always uses the segment selector part of the far address to access the corresponding descriptor in the <code>GDT</code> or <code>LDT</code>. The descriptor type (code segment, call gate, task gate, or <code>TSS</code>) and access rights determine the type of call operation to be performed.</li>
</ul>
<p>If the selected descriptor is for a code segment, a far call to a code segment at the same privilege level is performed. (If the selected code segment is at a different privilege level and the code segment is non-conforming, a general-protection exception is generated.) A far call to the same privilege level in protected mode is very similar to one carried out in real-address or virtual-8086 mode. The target operand specifies an absolute far address either directly with a pointer (<code>ptr16:16</code> or <code>ptr16:32</code>) or indirectly with a memory location (<code>m16:16</code> or <code>m16:32</code>). The operand- size attribute determines the size of the offset (16 or 32 bits) in the far address. The new code segment selector and its descriptor are loaded into <code>CS</code> register; the offset from the instruction is loaded into the <code>EIP</code> register.</p>
<p>A call gate (described in the next paragraph) can also be used to perform a far call to a code segment at the same privilege level. Using this mechanism provides an extra level of indirection and is the preferred method of making calls between 16-bit and 32-bit code segments.</p>
<p>When executing an inter-privilege-level far call, the code segment for the procedure being called must be accessed through a call gate. The segment selector specified by the target operand identifies the call gate. The target operand can specify the call gate segment selector either directly with a pointer (<code>ptr16:16</code> or <code>ptr16:32</code>) or indirectly with a memory location (<code>m16:16</code> or <code>m16:32</code>). The processor obtains the segment selector for the new code segment and the new instruction pointer (offset) from the call gate descriptor. (The offset from the target operand is ignored when a call gate is used.)</p>
<p>On inter-privilege-level calls, the processor switches to the stack for the privilege level of the called procedure. The segment selector for the new stack segment is specified in the <code>TSS</code> for the currently running task. The branch to the new code segment occurs after the stack switch. (Note that when using a call gate to perform a far call to a segment at the same privilege level, no stack switch occurs.) On the new stack, the processor pushes the segment selector and stack pointer for the calling procedure’s stack, an optional set of parameters from the calling procedures stack, and the segment selector and instruction pointer for the calling procedure’s code segment. (A value in the call gate descriptor determines how many parameters to copy to the new stack.) Finally, the processor branches to the address of the procedure being called within the new code segment.</p>
<p>Executing a task switch with the <code>CALL</code> instruction is similar to executing a call through a call gate. The target operand specifies the segment selector of the task gate for the new task activated by the switch (the offset in the target operand is ignored). The task gate in turn points to the <code>TSS</code> for the new task, which contains the segment selectors for the task’s code and stack segments. Note that the <code>TSS</code> also contains the <code>EIP</code> value for the next instruction that was to be executed before the calling task was suspended. This instruction pointer value is loaded into the <code>EIP</code> register to re-start the calling task.</p>
<p>The CALL instruction can also specify the segment selector of the TSS directly, which eliminates the indirection of the task gate. See Chapter 7, “Task Management,” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A, for information on the mechanics of a task switch.</p>
<p>When you execute at task switch with a <code>CALL</code> instruction, the nested task flag (<code>NT</code>) is set in the <code>EFLAGS</code> register and the new <code>TSS</code>’s previous task link field is loaded with the old task’s <code>TSS</code> selector. Code is expected to suspend this nested task by executing an <code>IRET</code> instruction which, because the <code>NT</code> flag is set, automatically uses the previous task link to return to the calling task. (See “Task Linking” in Chapter 7 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A, for information on nested tasks.) Switching tasks with the <code>CALL</code> instruction differs in this regard from <code>JMP</code> instruction. <code>JMP</code> does not set the <code>NT</code> flag and therefore does not expect an <code>IRET</code> instruction to suspend the task.</p>
<h3 id="mixing-16-bit-and-32-bit-calls"><a class="header" href="#mixing-16-bit-and-32-bit-calls">Mixing 16-Bit and 32-Bit Calls</a></h3>
<p>When making far calls between 16-bit and 32-bit code segments, use a call gate. If the far call is from a 32-bit code segment to a 16-bit code segment, the call should be made from the first 64 KBytes of the 32-bit code segment. This is because the operand-size attribute of the instruction is set to 16, so only a 16-bit return address offset can be saved. Also, the call should be made using a 16-bit call gate so that 16-bit values can be pushed on the stack. See Chapter 20, “Mixing 16-Bit and 32-Bit Code,” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3B, for more information.</p>
<h3 id="far-calls-in-compatibility-mode"><a class="header" href="#far-calls-in-compatibility-mode">Far Calls in Compatibility Mode</a></h3>
<p>When the processor is operating in compatibility mode, the <code>CALL</code> instruction can be used to perform the following types of far calls:</p>
<ul>
<li>Far call to the same privilege level, remaining in compatibility mode</li>
<li>Far call to the same privilege level, transitioning to 64-bit mode</li>
<li>Far call to a different privilege level (inter-privilege level call), transitioning to 64-bit mode
Note that a <code>CALL</code> instruction can not be used to cause a task switch in compatibility mode since task switches are not supported in IA-32e mode.</li>
</ul>
<p>In compatibility mode, the processor always uses the segment selector part of the far address to access the corresponding descriptor in the <code>GDT</code> or <code>LDT</code>. The descriptor type (code segment, call gate) and access rights determine the type of call operation to be performed.</p>
<p>If the selected descriptor is for a code segment, a far call to a code segment at the same privilege level is performed. (If the selected code segment is at a different privilege level and the code segment is non-conforming, a general-protection exception is generated.) A far call to the same privilege level in compatibility mode is very similar to one carried out in protected mode. The target operand specifies an absolute far address either directly with a pointer (<code>ptr16:16</code> or <code>ptr16:32</code>) or indirectly with a memory location (<code>m16:16</code> or <code>m16:32</code>). The operand-size attribute determines the size of the offset (16 or 32 bits) in the far address. The new code segment selector and its descriptor are loaded into <code>CS</code> register and the offset from the instruction is loaded into the <code>EIP</code> register. The difference is that 64-bit mode may be entered. This specified by the <code>L</code> bit in the new code segment descriptor.</p>
<p>Note that a 64-bit call gate (described in the next paragraph) can also be used to perform a far call to a code segment at the same privilege level. However, using this mechanism requires that the target code segment descriptor have the <code>L</code> bit set, causing an entry to 64-bit mode.</p>
<p>When executing an inter-privilege-level far call, the code segment for the procedure being called must be accessed through a 64-bit call gate. The segment selector specified by the target operand identifies the call gate. The target operand can specify the call gate segment selector either directly with a pointer (<code>ptr16:16</code> or <code>ptr16:32</code>) or indirectly with a memory location (<code>m16:16</code> or <code>m16:32</code>). The processor obtains the segment selector for the new code segment and the new instruction pointer (offset) from the 16-byte call gate descriptor. (The offset from the target operand is ignored when a call gate is used.)</p>
<p>On inter-privilege-level calls, the processor switches to the stack for the privilege level of the called procedure. The segment selector for the new stack segment is set to <code>NULL</code>. The new stack pointer is specified in the <code>TSS</code> for the currently running task. The branch to the new code segment occurs after the stack switch. (Note that when using a call gate to perform a far call to a segment at the same privilege level, an implicit stack switch occurs as a result of entering 64-bit mode. The <code>SS</code> selector is unchanged, but stack segment accesses use a segment base of <code>0x0</code>, the limit is ignored, and the default stack size is 64-bits. The full value of <code>RSP</code> is used for the offset, of which the upper 32-bits are undefined.) On the new stack, the processor pushes the segment selector and stack pointer for the calling procedure’s stack and the segment selector and instruction pointer for the calling procedure’s code segment. (Parameter copy is not supported in IA-32e mode.) Finally, the processor branches to the address of the procedure being called within the new code segment.</p>
<h3 id="nearfar-calls-in-64-bit-mode"><a class="header" href="#nearfar-calls-in-64-bit-mode">Near/(Far) Calls in 64-bit Mode</a></h3>
<p>When the processor is operating in 64-bit mode, the <code>CALL</code> instruction can be used to perform the following types of far calls:</p>
<ul>
<li>Far call to the same privilege level, transitioning to compatibility mode</li>
<li>Far call to the same privilege level, remaining in 64-bit mode</li>
<li>Far call to a different privilege level (inter-privilege level call), remaining in 64-bit mode
Note that in this mode the <code>CALL</code> instruction can not be used to cause a task switch in 64-bit mode since task switches are not supported in IA-32e mode.</li>
</ul>
<p>In 64-bit mode, the processor always uses the segment selector part of the far address to access the corresponding descriptor in the <code>GDT</code> or <code>LDT</code>. The descriptor type (code segment, call gate) and access rights determine the type of call operation to be performed.</p>
<p>If the selected descriptor is for a code segment, a far call to a code segment at the same privilege level is performed. (If the selected code segment is at a different privilege level and the code segment is non-conforming, a general-protection exception is generated.) A far call to the same privilege level in 64-bit mode is very similar to one carried out in compatibility mode. The target operand specifies an absolute far address indirectly with a memory location (<code>m16:16</code>, <code>m16:32</code> or <code>m16:64</code>). The form of <code>CALL</code> with a direct specification of absolute far address is not defined in 64-bit mode. The operand-size attribute determines the size of the offset (16, 32, or 64 bits) in the far address. The new code segment selector and its descriptor are loaded into the <code>CS</code> register; the offset from the instruction is loaded into the <code>EIP</code> register. The new code segment may specify entry either into compatibility or 64-bit mode, based on the <code>L</code> bit value.</p>
<p>A 64-bit call gate (described in the next paragraph) can also be used to perform a far call to a code segment at the same privilege level. However, using this mechanism requires that the target code segment descriptor have the <code>L</code> bit set.</p>
<p>When executing an inter-privilege-level far call, the code segment for the procedure being called must be accessed through a 64-bit call gate. The segment selector specified by the target operand identifies the call gate. The target operand can only specify the call gate segment selector indirectly with a memory location (<code>m16:16</code>, <code>m16:32</code> or <code>m16:64</code>). The processor obtains the segment selector for the new code segment and the new instruction pointer (offset) from the 16-byte call gate descriptor. (The offset from the target operand is ignored when a call gate is used.)</p>
<p>On inter-privilege-level calls, the processor switches to the stack for the privilege level of the called procedure. The segment selector for the new stack segment is set to <code>NULL</code>. The new stack pointer is specified in the <code>TSS</code> for the currently running task. The branch to the new code segment occurs after the stack switch.</p>
<p>Note that when using a call gate to perform a far call to a segment at the same privilege level, an implicit stack switch occurs as a result of entering 64-bit mode. The <code>SS</code> selector is unchanged, but stack segment accesses use a segment base of <code>0x0</code>, the limit is ignored, and the default stack size is 64-bits. (The full value of <code>RSP</code> is used for the offset.) On the new stack, the processor pushes the segment selector and stack pointer for the calling procedure’s stack and the segment selector and instruction pointer for the calling procedure’s code segment. (Parameter copy is not supported in IA-32e mode.) Finally, the processor branches to the address of the procedure being called within the new code segment.</p>
<p>Refer to Chapter 6, “Procedure Calls, Interrupts, and Exceptions” and Chapter 18, “Control-Flow Enforcement Technology (CET)” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1 for CET details.</p>
<h3 id="instruction-ordering-1"><a class="header" href="#instruction-ordering-1">Instruction ordering</a></h3>
<p>Instructions following a far call may be fetched from memory before earlier instructions complete execution, but they will not execute (even speculatively) until all instructions prior to the far call have completed execution (the later instructions may execute before data stored by the earlier instructions have become globally visible).</p>
<p>Certain situations may lead to the next sequential instruction after a near indirect <code>CALL</code> being speculatively executed. If software needs to prevent this (e.g., in order to prevent a speculative execution side channel), then an <code>LFENCE</code> instruction opcode can be placed after the near indirect <code>CALL</code> in order to block speculative execution.</p>
<h2 id="operation-23"><a class="header" href="#operation-23">Operation</a></h2>
<pre><code class="language-rust ignore">if /* near call */ {
    if /* near relative call */ {
        if OperandSize == 64 {
            tempDEST = SignExtend(DEST); // DEST is rel32
            tempRIP = RIP + tempDEST;
            if /* stack not large enough for a 8-byte return address */ {
                #SS(0);
            }
            Push(RIP);
            if ShadowStackEnabled(CPL) &amp;&amp; DEST != 0 {
                ShadowStackPush8B(RIP);
            }
            RIP = tempRIP;
        }
        if OperandSize == 32 {
            tempEIP = EIP + DEST; // DEST is rel32
            if /* tempEIP is not within code segment limit */ {
                #GP(0);
            }
            if /* stack not large enough for a 4-byte return address */ {
                #SS(0);
            }
            Push(EIP);
            if ShadowStackEnabled(CPL) &amp;&amp; DEST != 0 {
                ShadowStackPush4B(EIP);
            }
            EIP = tempEIP;
        }
        if OperandSize == 16 {
            tempEIP = (EIP + DEST) &amp;&amp; 0x0000_FFFF; // DEST is rel16
            if /* tempEIP is not within code segment limit */ {
                #GP(0);
            }
            if /* stack not large enough for a 2-byte return address */ {
                #SS(0);
            }
            Push(IP);
            if ShadowStackEnabled(CPL) &amp;&amp; DEST != 0 {
                // IP is zero extended and pushed as a 32 bit value on shadow stack
                ShadowStackPush4B(IP);
            }
            EIP = tempEIP;
        }
    } else { // near absolute call *)
        if OperandSize == 64 {
            tempRIP = DEST; // DEST is r/m64
            if /* stack not large enough for a 8-byte return address */ {
                #SS(0);
            }
            Push(RIP);
            if ShadowStackEnabled(CPL) {
                ShadowStackPush8B(RIP);
            }
            RIP = tempRIP;
        }
        if OperandSize == 32 {
            tempEIP = DEST; // DEST is r/m32
            if /* tempEIP is not within code segment limit */ {
                #GP(0);
            }
            if /* stack not large enough for a 4-byte return address */ {
                #SS(0);
            }
            Push(EIP);
            if ShadowStackEnabled(CPL) {
                ShadowStackPush4B(EIP);
            }
            EIP = tempEIP;
        }
        if OperandSize == 16 {
            tempEIP = DEST &amp;&amp; 0x0000_FFFF; // DEST is r/m16
            if /* tempEIP is not within code segment limit */ {
                #GP(0);
            }
            if /* stack not large enough for a 2-byte return address */ {
                #SS(0);
            }
            Push(IP);
            if ShadowStackEnabled(CPL) {
                // IP is zero extended and pushed as a 32 bit value on shadow stack
                ShadowStackPush4B(IP);
            }
            EIP = tempEIP;
        }
    } // rel/abs
    if /* Call near indirect, absolute indirect */ {
        if EndbranchEnabledAndNotSuppressed(CPL) {
            if CPL == 3 {
                if /* no 3EH prefix */ || IA32_U_CET.NO_TRACK_EN == 0 {
                    IA32_U_CET.TRACKER = WAIT_FOR_ENDBRANCH;
                }
            } else {
                IF /* no 3EH prefix */ || IA32_S_CET.NO_TRACK_EN == 0 {
                    IA32_S_CET.TRACKER = WAIT_FOR_ENDBRANCH;
                }
            }
        }
    }
} // near

if /* far call */ &amp;&amp; (PE == 0 || (PE == 1 &amp;&amp; VM == 1)) // real-address or virtual-8086 mode {
    if OperandSize == 32 {
        if /* stack not large enough for a 6-byte return address */ {
            #SS(0);
        }
        if /* DEST[16..=31] is not zero */ {
            #GP(0);
        }
        Push(CS); // padded with 16 high-order bits
        Push(EIP);
        CS = DEST[32..=47]; // DEST is ptr16:32 or [m16:32]
        EIP = DEST[0..=31]; // DEST is ptr16:32 or [m16:32]
    } else { // OperandSize == 16
        if /* stack not large enough for a 4-byte return address */ {
            #SS(0);
        }
        Push(CS);
        Push(IP);
        CS = DEST[16..=31]; // DEST is ptr16:16 or [m16:16]
        EIP = DEST[0..=15]; // DEST is ptr16:16 or [m16:16]; clear upper 16 bits
    }
}

if /* far call */ &amp;&amp; (PE == 1 and VM == 0) // protected mode or IA-32e Mode, not virtual-8086 mode
    if /* segment selector in target operand NULL */ {
        #GP(0);
    }
    if /* segment selector index not within descriptor table limits */ {
        #GP(new code segment selector);
    }
    /* Read type and access rights of selected segment descriptor; */
    if IA32_EFER.LMA == 0 {
        if /* segment type is not a conforming or nonconforming code segment, call
                gate, task gate, or TSS */ {
            #GP(segment selector);
        }
    } else {
        if /* segment type is not a conforming or nonconforming code segment or
                64-bit call gate */ {
            #GP(segment selector);
        }
    }
    /* Depending on type and access rights: */
        goto 'CONFORMING_CODE_SEGMENT;
        goto 'NONCONFORMING_CODE_SEGMENT;
        goto 'CALL_GATE;
        goto 'TASK_GATE;
        goto 'TASK_STATE_SEGMENT;
}

'CONFORMING_CODE_SEGMENT {
    if L-bit == 1 &amp;&amp; D-bit == 1 &amp;&amp; IA32_EFER.LMA == 1 {
        #GP(new code segment selector);
    }
    if DPL &gt; CPL {
        #GP(new code segment selector);
    }
    if /* segment not present */ {
        #NP(new code segment selector);
    }
    if /* stack not large enough for return address */ {
        #SS(0);
    }
    tempEIP = DEST(Offset);
    if target mode == Compatibility mode {
        tempEIP = tempEIP &amp;&amp; 0x0000_0000_FFFF_FFFF;
    }
    if OperandSize == 16 {
        tempEIP = tempEIP &amp;&amp; 0x0000_FFFF; // clear upper 16 bits
    }
    if (IA32_EFER.LMA == 0 || target mode == Compatibility mode) &amp;&amp; (/* tempEIP outside new code segment limit */)
        #GP(0);
    }
    if /* tempEIP is non-canonical */ {
        #GP(0);
    }
    if ShadowStackEnabled(CPL) {
        if OperandSize == 32 {
            tempPushLIP = CSBASE + EIP;
        } else {
            if OperandSize == 16 {
                tempPushLIP = CSBASE + IP;
            } else { // OperandSize == 64
                tempPushLIP = RIP;
            }
        }
        tempPushCS = CS;
    }
    if OperandSize == 32 {
        Push(CS); // padded with 16 high-order bits
        Push(EIP);
        CS = DEST(CodeSegmentSelector);
        // segment descriptor information also loaded
        CS(RPL) = CPL;
        EIP = tempEIP;
    } else {
        if OperandSize == 16 {
            Push(CS);
            Push(IP);
            CS = DEST(CodeSegmentSelector);
            // segment descriptor information also loaded
            CS(RPL) = CPL;
            EIP = tempEIP;
        } else { // OperandSize == 64
            Push(CS); // padded with 48 high-order bits
            Push(RIP);
            CS = DEST(CodeSegmentSelector);
            // segment descriptor information also loaded
            CS(RPL) = CPL;
            RIP = tempEIP;
        }
    }
    if ShadowStackEnabled(CPL) {
        if (IA32_EFER.LMA &amp; DEST(CodeSegmentSelector).L) == 0 {
            // If target is legacy or compatibility mode then the SSP must be in low 4GB
            if SSP &amp; 0xFFFF_FFFF_0000_0000 != 0 {
                #GP(0);
            }
        }
        // align to 8 byte boundary if not already aligned
        tempSSP = SSP;
        /* Shadow_stack_store 4 bytes of 0 to (SSP – 4) */
        SSP = SSP &amp; 0xFFFF_FFFF_FFFF_FFF8;
        ShadowStackPush8B(tempPushCS); // padded with 48 high-order bits of 0
        ShadowStackPush8B(tempPushLIP); // padded with 32 high-order bits of 0 for 32 bit LIP
        ShadowStackPush8B(tempSSP);
    }
    if EndbranchEnabled(CPL) {
        if CPL == 3 {
            IA32_U_CET.TRACKER = WAIT_FOR_ENDBRANCH;
            IA32_U_CET.SUPPRESS = 0;
        } else {
            IA32_S_CET.TRACKER = WAIT_FOR_ENDBRANCH;
            IA32_S_CET.SUPPRESS = 0;
        }
    }
}

'NONCONFORMING_CODE_SEGMENT {
    if L-Bit == 1 &amp;&amp; D-BIT == 1 &amp;&amp; IA32_EFER.LMA == 1 {
        #GP(new code segment selector);
    }
    if (RPL &gt; CPL) || (DPL != CPL) {
        #GP(new code segment selector);
    }
    if /* segment not present */ {
        #NP(new code segment selector);
    }
    if /* stack not large enough for return address */ {
        #SS(0);
    }
    tempEIP = DEST(Offset);
    if target mode == Compatibility mode {
        tempEIP = tempEIP &amp;&amp; 0x0000_0000_FFFF_FFFF;
    }
    if OperandSize == 16 {
        tempEIP = tempEIP &amp;&amp; 0x0000_FFFF; // clear upper 16 bits
    }
    if (IA32_EFER.LMA == 0 || target mode == Compatibility mode) &amp;&amp; /* tempEIP outside new code segment limit */ {
        #GP(0);
    }
    if /* tempEIP is non-canonical */ {
        #GP(0);
    }
    if ShadowStackEnabled(CPL) {
        if IA32_EFER.LMA &amp;&amp; CS.L {
            tempPushLIP = RIP;
        } else {
            tempPushLIP = CSBASE + EIP;
        }
        tempPushCS = CS;
    }
    if OperandSize == 32 {
        Push(CS); // padded with 16 high-order bits
        Push(EIP);
        CS = DEST(CodeSegmentSelector);
        // segment descriptor information also loaded
        CS(RPL) = CPL;
        EIP = tempEIP;
    } else {
        if OperandSize == 16 {
            Push(CS);
            Push(IP);
            CS = DEST(CodeSegmentSelector);
            // segment descriptor information also loaded
            CS(RPL) = CPL;
            EIP = tempEIP;
        } else { // OperandSize == 64
            Push(CS); // padded with 48 high-order bits
            Push(RIP);
            CS = DEST(CodeSegmentSelector);
            // segment descriptor information also loaded
            CS(RPL) = CPL;
            RIP = tempEIP;
        }
    }
    if ShadowStackEnabled(CPL) {
        if (IA32_EFER.LMA &amp;&amp; DEST(CodeSegmentSelector).L) == 0 {
            // if target is legacy or compatibility mode then the SSP must be in low 4GB
            if SSP &amp; 0xFFFF_FFFF_0000_0000 != 0 {
                #GP(0);
            }
        }
        // align to 8 byte boundary if not already aligned
        tempSSP = SSP;
        /* Shadow_stack_store 4 bytes of 0 to (SSP – 4) */
        SSP = SSP &amp; 0xFFFF_FFFF_FFFF_FFF8;
        ShadowStackPush8B(tempPushCS); // padded with 48 high-order 0 bits
        ShadowStackPush8B(tempPushLIP); // padded 32 high-order bits of 0 for 32 bit LIP
        ShadowStackPush8B(tempSSP);
    }
    if EndbranchEnabled(CPL) {
        if CPL == 3 {
            IA32_U_CET.TRACKER = WAIT_FOR_ENDBRANCH;
            IA32_U_CET.SUPPRESS = 0;
        } else {
            IA32_S_CET.TRACKER = WAIT_FOR_ENDBRANCH;
            IA32_S_CET.SUPPRESS = 0;
        }
    }
}

'CALL_GATE {
    if call gate (DPL &lt; CPL) || (RPL &gt; DPL) {
        #GP(call-gate selector);
    }
    if /* call gate not present */ {
        #NP(call-gate selector);
    }
    if /* call-gate code-segment selector is NULL */ {
        #GP(0);
    }
    if /* call-gate code-segment selector index is outside descriptor table limits */ {
        #GP(call-gate code-segment selector);
    }
    /* Read call-gate code-segment descriptor; */
    if /* call-gate code-segment descriptor does not indicate a code segment */
            || call-gate code-segment descriptor DPL &gt; CPL {
        #GP(call-gate code-segment selector);
    }
    if IA32_EFER.LMA == 1 &amp;&amp; (/* call-gate code-segment descriptor is
            not a 64-bit code segment */ || /* call-gate code-segment descriptor has both L-bit and D-bit set */) {
        #GP(call-gate code-segment selector);
    }
    if /* call-gate code segment not present */ {
        #NP(call-gate code-segment selector);
    }
    if /* call-gate code segment is non-conforming */ &amp;&amp; DPL &lt; CPL {
        goto 'MORE_PRIVILEGE;
    } else {
        goto 'SAME_PRIVILEGE;
    }
}

'MORE_PRIVILEGE {
    if /* current TSS is 32-bit */ {
        TSSstackAddress = (new code-segment DPL ∗ 8) + 4;
        if (TSSstackAddress + 5) &gt; current TSS limit {
            #TS(current TSS selector);
        }
        NewSS = 2 bytes loaded from (TSS base + TSSstackAddress + 4);
        NewESP = 4 bytes loaded from (TSS base + TSSstackAddress);
    } else {
        if /* current TSS is 16-bit */ {
            TSSstackAddress = (new code-segment DPL ∗ 4) + 2;
            if (TSSstackAddress + 3) &gt; current TSS limit {
                #TS(current TSS selector);
            }
            NewSS = 2 bytes loaded from (TSS base + TSSstackAddress + 2);
            NewESP = 2 bytes loaded from (TSS base + TSSstackAddress);
        } else { // current TSS is 64-bit
            TSSstackAddress = (new code-segment DPL ∗ 8) + 4;
            if (TSSstackAddress + 7) &gt; current TSS limit {
                #TS(current TSS selector);
            }
            NewSS = new code-segment DPL; // NULL selector with RPL = new CPL
            NewRSP = 8 bytes loaded from (current TSS base + TSSstackAddress);
        }
    }
    if IA32_EFER.LMA == 0 &amp;&amp; /* NewSS is NULL */ {
        #TS(NewSS);
    }
    /* Read new stack-segment descriptor; */
    if IA32_EFER.LMA == 0 &amp;&amp; (NewSS RPL != new code-segment DPL
            || new stack-segment DPL != new code-segment DPL || /* new stack segment is not a
            writable data segment */) {
        #TS(NewSS);
    }
    if IA32_EFER.LMA == 0 &amp;&amp; /* new stack segment not present */ {
        #SS(NewSS);
    }
    if CallGateSize == 32 {
        if /* new stack does not have room for parameters plus 16 bytes */ {
            #SS(NewSS);
        }
        if /* CallGate(InstructionPointer) not within new code-segment limit */ {
            #GP(0);
        }
        SS = newSS; // segment descriptor information also loaded
        ESP = newESP;
        CS:EIP = CallGate(CS:InstructionPointer);
        // segment descriptor information also loaded
        Push(oldSS:oldESP); // from calling procedure
        temp = /* parameter count from call gate, masked to 5 bits */;
        Push(parameters from calling procedure's stack, temp);
        Push(oldCS:oldEIP); // return address to calling procedure
    } else {
        if CallGateSize == 16 {
            if /* new stack does not have room for parameters plus 8 bytes */ {
                #SS(NewSS);
            }
            if /* (CallGate(InstructionPointer) &amp;&amp; 0xFFFF) not in new code-segment limit */ {
                #GP(0);
            }
            SS = newSS; // segment descriptor information also loaded
            ESP = newESP;
            CS:IP = CallGate(CS:InstructionPointer);
            // segment descriptor information also loaded
            Push(oldSS:oldESP); // From calling procedure
            temp = /* parameter count from call gate, masked to 5 bits */;
            Push(parameters from calling procedure's stack, temp);
            Push(oldCS:oldEIP); // Return address to calling procedure
        } else { // CallGateSize == 64
            if /* pushing 32 bytes on the stack would use a non-canonical address */ {
                #SS(NewSS);
            }
            if /* CallGate(InstructionPointer) is non-canonical */ {
                #GP(0);
            }
            SS = NewSS; // NewSS is NULL
            RSP = NewESP;
            CS:IP = CallGate(CS:InstructionPointer);
            // segment descriptor information also loaded
            Push(oldSS:oldESP); // from calling procedure
            Push(oldCS:oldEIP); // return address to calling procedure
        }
    }
    if ShadowStackEnabled(CPL) &amp;&amp; CPL == 3 {
        if IA32_EFER.LMA == 0 {
            IA32_PL3_SSP = SSP;
        } else { // adjust so bits 63:N get the value of bit N–1, where N is the CPU's maximum linear-address width
        IA32_PL3_SSP = LA_adjust(SSP);
        }
    }
    CPL = CodeSegment(DPL)
    CS(RPL) = CPL
    if ShadowStackEnabled(CPL) {
        oldSSP = SSP;
        SSP = IA32_PLi_SSP; // where i is the CPL
        if SSP &amp; 0x07 != 0 // if SSP not aligned to 8 bytes then #GP {
            #GP(0);
        }
        // token and CS:LIP:oldSSP pushed on shadow stack must be contained in a naturally aligned 32-byte region
        if (SSP &amp; ~0x1F) != ((SSP – 24) &amp; ~0x1F) {
            #GP(0);
        }
        if (IA32_EFER.LMA and CS.L) == 0 &amp;&amp; SSP[32..=63] != 0 {
            #GP(0);
        }
        expected_token_value = SSP;
        // busy bit - bit position 0 - must be clear
        new_token_value = SSP | BUSY_BIT;
        // set the busy bit
        if shadow_stack_lock_cmpxchg8b(SSP, new_token_value, expected_token_value) != expected_token_value {
            #GP(0);
        }
        if oldSS.DPL != 3 {
            // these stack pushes should not cause faults, VM exits, or data breakpoints
            // such events will apply to the earlier accesses to the token, which is in the same naturally aligned 32-byte region
            ShadowStackPush8B(oldCS); // padded with 48 high-order bits of 0
            ShadowStackPush8B(oldCSBASE+oldRIP); // padded with 32 high-order bits of 0 for 32 bit LIP
            ShadowStackPush8B(oldSSP);
        }
    }
    if EndbranchEnabled(CPL) {
        IA32_S_CET.TRACKER = WAIT_FOR_ENDBRANCH;
        IA32_S_CET.SUPPRESS = 0;
    }
}

'SAME_PRIVILEGE {
    if CallGateSize == 32 {
        if /* stack does not have room for 8 bytes */ {
            #SS(0);
        }
        if /* CallGate(InstructionPointer) not within code segment limit */ {
            #GP(0);
        }
        CS:EIP = CallGate(CS:EIP); // segment descriptor information also loaded
        Push(oldCS:oldEIP); // return address to calling procedure
    } else {
        if CallGateSize == 16 {
            if /* stack does not have room for 4 bytes */ {
                #SS(0);
            }
            if /* CallGate(InstructionPointer) not within code segment limit */ {
                #GP(0);
            }
            CS:IP = CallGate(CS:instruction pointer);
            // segment descriptor information also loaded
            Push(oldCS:oldIP); // return address to calling procedure
        } else { // CallGateSize == 64
            if /* pushing 16 bytes on the stack touches non-canonical addresses */ {
                #SS(0);
            }
            if /* RIP non-canonical */ {
                #GP(0);
            }
            CS:IP = CallGate(CS:instruction pointer);
            // segment descriptor information also loaded
            Push(oldCS:oldIP); // return address to calling procedure
        }
    }
    CS(RPL) = CPL;
    if ShadowStackEnabled(CPL) {
        // align to next 8 byte boundary
        tempSSP = SSP;
        /* Shadow_stack_store 4 bytes of 0 to (SSP – 4) */
        SSP = SSP &amp; 0xFFFF_FFFF_FFFF_FFF8;
        // push cs:lip:ssp on shadow stack
        ShadowStackPush8B(oldCS); // padded with 48 high-order bits of 0
        ShadowStackPush8B(oldCSBASE + oldRIP); // padded with 32 high-order bits of 0 for 32 bit LIP
        ShadowStackPush8B(tempSSP);
    }
    if EndbranchEnabled(CPL) {
        if CPL == 3 {
            IA32_U_CET.TRACKER = WAIT_FOR_ENDBRANCH;
            IA32_U_CET.SUPPRESS = 0;
        } else {
            IA32_S_CET.TRACKER = WAIT_FOR_ENDBRANCH;
            IA32_S_CET.SUPPRESS = 0;
        }
    }
}

'TASK_GATE {
    if task gate DPL &lt; CPL || RPL {
        #GP(task gate selector);
    }
    if /* task gate not present */ {
        #NP(task gate selector);
    }
    /* Read the TSS segment selector in the task-gate descriptor; */
    if /* TSS segment selector local/global bit is set to local */
            || /* index not within GDT limits */ {
        #GP(TSS selector);
    }
    /* Access TSS descriptor in GDT; */
    if /* descriptor is not a TSS segment */ {
        #GP(TSS selector);
    }
    if /* TSS descriptor specifies that the TSS is busy */ {
        #GP(TSS selector);
    }
    if /* TSS not present */ {
        #NP(TSS selector);
    }
    /* SWITCH-TASKS (with nesting) to TSS; */
    if /* EIP not within code segment limit */ {
        #GP(0);
    }
}

'TASK_STATE_SEGMENT {
    if TSS DPL &lt; CPL || RPL
            || /* TSS descriptor indicates TSS not available */ {
        #GP(TSS selector);
    }
    if /* TSS is not present */ {
        #NP(TSS selector);
    }
    /* SWITCH-TASKS (with nesting) to TSS; */ {
    if /* EIP not within code segment limit */ {
        #GP(0);
    }
}
</code></pre>
<h2 id="flags-affected-22"><a class="header" href="#flags-affected-22">Flags Affected</a></h2>
<p>All flags are affected if a task switch occurs; no flags are affected if a task switch does not occur.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="ret"><a class="header" href="#ret"><code>RET</code></a></h1>
<p>Return from Procedure</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Instruction</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>RET</code></td><td style="text-align: left">Near return to calling procedure</td></tr>
<tr><td style="text-align: left"><code>RET</code></td><td style="text-align: left">Far return to calling procedure</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>RET imm16</code></td><td style="text-align: left">Near return to calling procedure and pop <code>imm16</code> bytes from stack</td></tr>
<tr><td style="text-align: left"><code>RET imm16</code></td><td style="text-align: left">Far return to calling procedure and pop <code>imm16</code> bytes from stack</td></tr>
</tbody></table>
</div>
<h2 id="description-23"><a class="header" href="#description-23">Description</a></h2>
<p>Transfers program control to a return address located on the top of the stack. The address is usually placed on the stack by a <code>CALL</code> instruction, and the return is made to the instruction that follows the <code>CALL</code> instruction.</p>
<p>The optional source operand specifies the number of stack bytes to be released after the return address is popped; the default is none. This operand can be used to release parameters from the stack that were passed to the called procedure and are no longer needed. It must be used when the <code>CALL</code> instruction used to switch to a new procedure uses a call gate with a non-zero word count to access the new procedure. Here, the source operand for the <code>RET</code> instruction must specify the same number of bytes as is specified in the word count field of the call gate.</p>
<p>The <code>RET</code> instruction can be used to execute three different types of returns:</p>
<ul>
<li><strong>Near return</strong><br />
A return to a calling procedure within the current code segment (the segment currently pointed to by the <code>CS</code> register), sometimes referred to as an intrasegment return.</li>
<li><strong>Far return</strong><br />
A return to a calling procedure located in a different segment than the current code segment, sometimes referred to as an intersegment return.</li>
<li><strong>Inter-privilege-level far return</strong><br />
A far return to a different privilege level than that of the currently executing program or procedure.
The inter-privilege-level return type can only be executed in protected mode. See the section titled “Calling Procedures Using Call and RET” in Chapter 6 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for detailed information on near, far, and inter-privilege-level returns.</li>
</ul>
<p>When executing a near return, the processor pops the return instruction pointer (offset) from the top of the stack into the <code>EIP</code> register and begins program execution at the new instruction pointer. The <code>CS</code> register is unchanged.</p>
<p>When executing a far return, the processor pops the return instruction pointer from the top of the stack into the <code>EIP</code> register, then pops the segment selector from the top of the stack into the <code>CS</code> register. The processor then begins program execution in the new code segment at the new instruction pointer.</p>
<p>The mechanics of an inter-privilege-level far return are similar to an intersegment return, except that the processor examines the privilege levels and access rights of the code and stack segments being returned to determine if the control transfer is allowed to be made. The <code>DS</code>, <code>ES</code>, <code>FS</code>, and <code>GS</code> segment registers are cleared by the <code>RET</code> instruction during an inter-privilege-level return if they refer to segments that are not allowed to be accessed at the new privilege level. Since a stack switch also occurs on an inter-privilege level return, the <code>ESP</code> and <code>SS</code> registers are loaded from the stack.</p>
<p>If parameters are passed to the called procedure during an inter-privilege level call, the optional source operand must be used with the <code>RET</code> instruction to release the parameters on the return. Here, the parameters are released both from the called procedure’s stack and the calling procedure’s stack (that is, the stack being returned to).</p>
<p>In 64-bit mode, the default operation size of this instruction is the stack-address size, i.e. 64 bits. This applies to near returns, not far returns; the default operation size of far returns is 32 bits.</p>
<p>Refer to Chapter 6, “Procedure Calls, Interrupts, and Exceptions” and Chapter 18, “Control-Flow Enforcement Technology (CET)” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1 for CET details.</p>
<h3 id="instruction-ordering-2"><a class="header" href="#instruction-ordering-2">Instruction ordering</a></h3>
<p>Instructions following a far return may be fetched from memory before earlier instructions complete execution, but they will not execute (even speculatively) until all instructions prior to the far return have completed execution (the later instructions may execute before data stored by the earlier instructions have become globally visible).</p>
<p>Unlike near indirect <code>CALL</code> and near indirect <code>JMP</code>, the processor will not speculatively execute the next sequential instruction after a near <code>RET</code> unless that instruction is also the target of a jump or is a target in a branch predictor.</p>
<h2 id="operation-24"><a class="header" href="#operation-24">Operation</a></h2>
<pre><code class="language-rust ignore">// near return
if instruction == near return {
    if OperandSize == 32 {
        if /* top 4 bytes of stack not within stack limits */ {
            #SS(0);
        }
        EIP = Pop();
        if ShadowStackEnabled(CPL) {
            tempSsEIP = ShadowStackPop4B();
            if EIP != TempSsEIP {
                #CP(NEAR_RET);
            }
        }
    } else {
        if OperandSize == 64 {
            if /* top 8 bytes of stack not within stack limits */ {
                #SS(0);
            }
            RIP = Pop();
            if ShadowStackEnabled(CPL) {
                tempSsEIP = ShadowStackPop8B();
                if RIP != tempSsEIP {
                    #CP(NEAR_RET);
                }
            }
        } else { // OperandSize == 16
            if /* top 2 bytes of stack not within stack limits */ {
                #SS(0);
            }
            tempEIP = Pop();
            tempEIP = tempEIP &amp;&amp; 0x0000_FFFF;
            if /* tempEIP not within code segment limits */ {
                #GP(0);
            }
            EIP = tempEIP;
            if ShadowStackEnabled(CPL) {
                tempSsEip = ShadowStackPop4B();
                if EIP != tempSsEIP {
                    #CP(NEAR_RET);
                }
            }
        }
    }
    if /* instruction has immediate operand */ {
        // release parameters from stack
        if StackAddressSize == 32 {
            ESP = ESP + SRC;
        } else {
            if StackAddressSize == 64 {
                RSP = RSP + SRC;
            } else { // StackAddressSize == 16
                SP = SP + SRC;
            }
        }
    }
}

// real-address mode or virtual-8086 mode
if ((PE == 0) || (PE == 1 &amp;&amp; VM == 1)) &amp;&amp; instruction == far return {
    if OperandSize == 32 {
        if /* top 8 bytes of stack not within stack limits */ {
            #SS(0);
        }
        EIP = Pop();
        CS = Pop(); // 32-bit pop, high-order 16 bits discarded
    } else { // OperandSize == 16
        if /* top 4 bytes of stack not within stack limits */ {
            #SS(0);
        }
        tempEIP = Pop();
        tempEIP = tempEIP &amp;&amp; 0x0000_FFFF;
        if /* tempEIP not within code segment limits */ {
            #GP(0);
        }
        EIP = tempEIP;
        CS = Pop(); // 16-bit pop
    }
    if /* instruction has immediate operand */ {
        // release parameters from stack
        SP = SP + (SRC &amp;&amp; 0xFFFF);
    }
}

// protected mode, not virtual-8086 mode
if (PE == 1 &amp;&amp; VM == 0 &amp;&amp; IA32_EFER.LMA == 0) &amp;&amp; instruction == far return {
    if OperandSize == 32 {
        if /* second doubleword on stack is not within stack limits */ {
            #SS(0);
        }
    } else { // OperandSize == 16
        if /* second word on stack is not within stack limits */ {
            #SS(0);
        }
    }
    if /* return code segment selector is NULL */ {
        #GP(0);
    }
    if /* return code segment selector addresses descriptor beyond descriptor table limit */ {
        #GP(selector);
    }
    /* Obtain descriptor to which return code segment selector points from descriptor table; */
    if /* return code segment descriptor is not a code segment */ {
        #GP(selector);
    }
    if return code segment selector RPL &lt; CPL {
        #GP(selector);
    }
    if /* return code segment descriptor is conforming */
            &amp;&amp; return code segment DPL &gt; return code segment selector RPL {
        #GP(selector);
    }
    if /* return code segment descriptor is non-conforming */
            &amp;&amp; return code segment DPL != return code segment selector RPL {
        #GP(selector);
    }
    if /* return code segment descriptor is not present */ {
        #NP(selector);
    }
    if return code segment selector RPL &gt; CPL {
        goto 'RETURN_TO_OUTER_PRIVILEGE_LEVEL;
    } else {
        goto 'RETURN_TO_SAME_PRIVILEGE_LEVEL;
    }
}

'RETURN_TO_SAME_PRIVILEGE_LEVEL {
    if /* the return instruction pointer is not within the return code segment limit */ {
        #GP(0);
    }
    if OperandSize == 32 {
        EIP = Pop();
        CS = Pop(); // 32-bit pop, high-order 16 bits discarded
    } else { // OperandSize == 16
        EIP = Pop();
        EIP = EIP &amp;&amp; 0x0000_FFFF;
        CS = Pop(); // 16-bit pop
    }
    if /* instruction has immediate operand */ {
        // release parameters from stack
        if StackAddressSize == 32 {
            ESP = ESP + SRC;
        } else { // StackAddressSize == 16
            SP = SP + SRC;
        }
    }
    if ShadowStackEnabled(CPL) {
        // SSP must be 8 byte aligned
        if SSP &amp;&amp; 0x7 != 0 {
            #CP(FAR-RET/IRET);
        }
        tempSsCS = shadow_stack_load 8 bytes from SSP+16;
        tempSsLIP = shadow_stack_load 8 bytes from SSP+8;
        prevSSP = shadow_stack_load 8 bytes from SSP;
        SSP = SSP + 24;
        // do a 64 bit-compare to check if any bits beyond bit 15 are set
        tempCS = CS; // zero pad to 64 bit
        if tempCS != tempSsCS {
            #CP(FAR-RET/IRET);
        }
        // do a 64 bit-compare; pad CSBASE+RIP with 0 for 32 bit LIP
        if CSBASE + RIP != tempSsLIP {
            #CP(FAR-RET/IRET);
        }
        // prevSSP must be 4 byte aligned
        if prevSSP &amp;&amp; 0x3 != 0 {
            #CP(FAR-RET/IRET);
        }
        // in legacy mode SSP must be in low 4GB
        if prevSSP[32..=63] != 0 {
            #GP(0);
        }
        SSP = prevSSP;
    }
}

'RETURN_TO_OUTER_PRIVILEGE_LEVEL {
    if /* top (16 + SRC) bytes of stack are not within stack limits (OperandSize == 32) */
            || /* top (8 + SRC) bytes of stack are not within stack limits (OperandSize == 16) */ {
        #SS(0);
    }
    /* Read return segment selector; */
    if /* stack segment selector is NULL */ {
        #GP(0);
    }
    if /* return stack segment selector index is not within its descriptor table limits */ {
        #GP(selector);
    }
    /* Read segment descriptor pointed to by return segment selector; */
    if stack segment selector RPL != RPL of the return code segment selector
            || /* stack segment is not a writable data segment */
            || stack segment descriptor DPL != RPL of the return code segment selector {
        #GP(selector);
    }
    if /* stack segment not present */ {
        #SS(StackSegmentSelector);
    }
    if /* the return instruction pointer is not within the return code segment limit */ {
        #GP(0);
    }
    if OperandSize == 32 {
        EIP = Pop();
        CS = Pop(); // 32-bit pop, high-order 16 bits discarded; segment descriptor loaded
        CS(RPL) = ReturnCodeSegmentSelector(RPL);
        if /* instruction has immediate operand */ {
            // release parameters from called procedure's stack
            if StackAddressSize == 32 {
                ESP = ESP + SRC;
            } else { // StackAddressSize == 16
                SP = SP + SRC;
            }
        }
        tempESP = Pop();
        tempSS = Pop(); // 32-bit pop, high-order 16 bits discarded; seg. descriptor loaded
    } else { // OperandSize == 16
        EIP = Pop();
        EIP = EIP &amp;&amp; 0x0000_FFFF;
        CS = Pop(); // 16-bit pop; segment descriptor loaded
        CS(RPL) = ReturnCodeSegmentSelector(RPL);
        if /* instruction has immediate operand */ {
            // release parameters from called procedure's stack
            if StackAddressSize == 32 {
                ESP = ESP + SRC;
            } else { // StackAddressSize == 16
                SP = SP + SRC;
            }
        }
        tempESP = Pop();
        tempSS = Pop(); // 16-bit pop; segment descriptor loaded
    }
    if ShadowStackEnabled(CPL) {
        // check if 8 byte aligned
        if SSP &amp;&amp; 0x7 != 0 {
            #CP(FAR-RET/IRET);
        }
        if ReturnCodeSegmentSelector(RPL) != 3 {
            tempSsCS = shadow_stack_load 8 bytes from SSP+16;
            tempSsLIP = shadow_stack_load 8 bytes from SSP+8;
            tempSSP = shadow_stack_load 8 bytes from SSP;
            SSP = SSP + 24;
            // do 64 bit compare to detect bits beyond 15 being set
            tempCS = CS; // zero extended to 64 bit
            if tempCS != tempSsCS {
                #CP(FAR-RET/IRET);
            }
            // do 64 bit compare; pad CSBASE+RIP with 0 for 32 bit LA
            if CSBASE + RIP != tempSsLIP {
                #CP(FAR-RET/IRET);
            }
            // check if 4 byte aligned
            if tempSSP &amp;&amp; 0x3 != 0 {
                #CP(FAR-RET/IRET);
            }
        }
    }
    tempOldCPL = CPL;

    CPL = ReturnCodeSegmentSelector(RPL);
    ESP = tempESP;
    SS = tempSS;
    tempOldSSP = SSP;
    if ShadowStackEnabled(CPL) {
        if CPL == 3 {
            tempSSP = IA32_PL3_SSP;
        }
        if tempSSP[32..=63] != 0 {
            #GP(0);
        }
        SSP = tempSSP;
    }
    // Now past all faulting points; safe to free the token. The token free is done using the old SSP
    // and using a supervisor override as old CPL was a supervisor privilege level
    if ShadowStackEnabled(tempOldCPL) {
        expected_token_value = tempOldSSP | BUSY_BIT; // busy bit - bit position 0 - must be set
        new_token_value = tempOldSSP; // clear the busy bit
        shadow_stack_lock_cmpxchg8b(tempOldSSP, new_token_value, expected_token_value);
    }
    for SegReg in (ES, FS, GS, and DS) {
        tempDesc = /* descriptor cache for SegReg */; // hidden part of segment register
        if SegmentSelector == NULL || (tempDesc(DPL) &lt; CPL &amp;&amp; tempDesc(Type) is (/* data or non-conforming code */)) {
            // segment register invalid
            SegmentSelector = 0; // segment selector becomes null
        }
    }
    if /* instruction has immediate operand */ {
        // release parameters from calling procedure's stack
        if StackAddressSize == 32 {
            ESP = ESP + SRC;
        } else { // StackAddressSize == 16
            SP = SP + SRC;
        }
    }

    // IA-32e Mode
    if (PE == 1 &amp;&amp; VM == 0 &amp;&amp; IA32_EFER.LMA == 1) &amp;&amp; instruction == far return {
        if OperandSize == 32 {
            if /* second doubleword on stack is not within stack limits */ {
                #SS(0);
            }
            if /* first or second doubleword on stack is not in canonical space */ {
                #SS(0);
            }
        } else {
            if OperandSize == 16 {
                if /* second word on stack is not within stack limits */ {
                    #SS(0);
                }
                if /* first or second word on stack is not in canonical space */ {
                    #SS(0);
                }
            } else { // OperandSize == 64
                if /* first or second quadword on stack is not in canonical space */ {
                    #SS(0);
                }
            }
        }
        if /* return code segment selector is NULL */ {
            #GP(0);
        }
        if /* return code segment selector addresses descriptor beyond descriptor table limit */ {
            #GP(selector);
        }
        if /* return code segment selector addresses descriptor in non-canonical space */ {
            #GP(selector);
        }
        /* obtain descriptor to which return code segment selector points from descriptor table; */
        if /* return code segment descriptor is not a code segment */ {
            #GP(selector);
        }
        if /* return code segment descriptor has L-bit == 1 and D-bit == 1 */ {
            #GP(selector);
        }
        if return code segment selector RPL &lt; CPL {
            #GP(selector);
        }
        if /* return code segment descriptor is conforming */
                &amp;&amp; return code segment DPL &gt; return code segment selector RPL {
            #GP(selector);
        }
        if /* return code segment descriptor is non-conforming */
                &amp;&amp; return code segment DPL != return code segment selector RPL {
            #GP(selector);
        }
        if /* return code segment descriptor is not present */ {
            #NP(selector);
        }
        if return code segment selector RPL &gt; CPL {
            goto 'IA_32E_MODE_RETURN_TO_OUTER_PRIVILEGE_LEVEL;
        } else {
            goto 'IA_32E_MODE_RETURN_TO_SAME_PRIVILEGE_LEVEL;
        }
    }
}

'IA_32E_MODE_RETURN_TO_SAME_PRIVILEGE_LEVEL {
    if /* the return instruction pointer is not within the return code segment limit */ {
        #GP(0);
    }
    if /* the return instruction pointer is not within canonical address space */ {
        #GP(0);
    }
    if OperandSize == 32 {
        EIP = Pop();
        CS = Pop(); // 32-bit pop, high-order 16 bits discarded
    } else {
        if OperandSize == 16 {
            EIP = Pop();
            EIP = EIP &amp;&amp; 0x0000_FFFF;
            CS = Pop(); // 16-bit pop
        } else { // OperandSize == 64
            RIP = Pop();
            CS = Pop(); // 64-bit pop, high-order 48 bits discarded
        }
    }
    if /* instruction has immediate operand */ {
        // release parameters from stack
        if StackAddressSize == 32 {
            ESP = ESP + SRC;
        } else {
            if StackAddressSize == 16 {
                SP = SP + SRC;
            } else { // StackAddressSize == 64
                RSP = RSP + SRC;
            }
        }
    }
    if ShadowStackEnabled(CPL) {
        if SSP &amp;&amp; 0x7 != 0 {
            // check if aligned to 8 bytes
            #CP(FAR-RET/IRET);
        }
        tempSsCS = shadow_stack_load 8 bytes from SSP+16;
        tempSsLIP = shadow_stack_load 8 bytes from SSP+8;
        tempSSP = shadow_stack_load 8 bytes from SSP;
        SSP = SSP + 24;
        tempCS = CS; // zero padded to 64 bit
        if tempCS != tempSsCS {
            // 64 bit compare; CS zero padded to 64 bits
            #CP(FAR-RET/IRET);
        }
        if CSBASE + RIP != tempSsLIP {
            // 64 bit compare
            #CP(FAR-RET/IRET);
        }
        if tempSSP &amp;&amp; 0x3 != 0 {
            // check if aligned to 4 bytes
            #CP(FAR-RET/IRET);
        }
        if (CS.L == 0 &amp;&amp; tempSSP[32..=63] != 0)
                || (CS.L == 1 &amp;&amp; /* tempSSP is not canonical relative to the current paging mode */) {
            #GP(0);
        }
        SSP = tempSSP;
    }
}

'IA_32E_MODE_RETURN_TO_OUTER_PRIVILEGE_LEVEL {
    if /* top (16 + SRC) bytes of stack are not within stack limits (OperandSize == 32) */
            || /* top (8 + SRC) bytes of stack are not within stack limits (OperandSize == 16) */ {
        #SS(0);
    }
    if /* top (16 + SRC) bytes of stack are not in canonical address space (OperandSize == 32) */
            || /* top (8 + SRC) bytes of stack are not in canonical address space (OperandSize == 16) */
            || /* top (32 + SRC) bytes of stack are not in canonical address space (OperandSize == 64) */ {
        #SS(0);
    }
    /* Read return stack segment selector; */
    if /* stack segment selector is NULL */ {
        if new CS descriptor L-bit == 0 {
            #GP(selector);
        }
        if stack segment selector RPL == 3 {
            #GP(selector);
        }
    }
    if /* return stack segment descriptor is not within descriptor table limits */ {
        #GP(selector);
    }
    if /* return stack segment descriptor is in non-canonical address space */ {
        #GP(selector);
    }
    /* Read segment descriptor pointed to by return segment selector; */
    if stack segment selector RPL != RPL of the return code segment selector
            || /* stack segment is not a writable data segment */
            || stack segment descriptor DPL != RPL of the return code segment selector {
        #GP(selector);
    }
    if /* stack segment not present */ {
        #SS(StackSegmentSelector);
    }
    if /* the return instruction pointer is not within the return code segment limit */ {
        #GP(0);
    }
    if /* the return instruction pointer is not within canonical address space */ {
        #GP(0);
    }
    if OperandSize == 32 {
        EIP = Pop();
        CS = Pop(); // 32-bit pop, high-order 16 bits discarded, segment descriptor loaded
        CS(RPL) = ReturnCodeSegmentSelector(RPL);
        if /* instruction has immediate operand */ {
            // release parameters from called procedure's stack
            if StackAddressSize == 32 {
                ESP = ESP + SRC;
            } else {
                if StackAddressSize == 16 {
                    SP = SP + SRC;
                } else { // StackAddressSize == 64
                    RSP = RSP + SRC;
                }
            }
        }
        tempESP = Pop();
        tempSS = Pop(); // 32-bit pop, high-order 16 bits discarded, segment descriptor loaded
    } else {
        if OperandSize == 16 {
            EIP = Pop();
            EIP = EIP &amp;&amp; 0x0000_FFFF;
            CS = Pop(); // 16-bit pop; segment descriptor loaded
            CS(RPL) = ReturnCodeSegmentSelector(RPL);
            if /* instruction has immediate operand */ {
                // release parameters from called procedure's stack
                if StackAddressSize == 32 {
                    ESP = ESP + SRC;
                } else {
                    if StackAddressSize == 16 {
                        SP = SP + SRC;
                    } else { // StackAddressSize == 64
                        RSP = RSP + SRC;
                    }
                }
            }
            tempESP = Pop();
            tempSS = Pop(); // 16-bit pop; segment descriptor loaded
        } else { // OperandSize = 64
            RIP = Pop();
            CS = Pop(); // 64-bit pop; high-order 48 bits discarded; seg. descriptor loaded
            CS(RPL) = ReturnCodeSegmentSelector(RPL);
            if /* instruction has immediate operand */ {
                // Release parameters from called procedure's stack
                RSP = RSP + SRC;
            }
            tempESP = Pop();
            tempSS = Pop(); // 64-bit pop; high-order 48 bits discarded; seg. desc. loaded
        }
    }

    if ShadowStackEnabled(CPL) {
        // check if 8 byte aligned
        if SSP &amp;&amp; 0x7 != 0 {
            #CP(FAR-RET/IRET);
        }
        if ReturnCodeSegmentSelector(RPL) != 3 {
            tempSsCS = shadow_stack_load 8 bytes from SSP+16;
            tempSsLIP = shadow_stack_load 8 bytes from SSP+8;
            tempSSP = shadow_stack_load 8 bytes from SSP;
            SSP = SSP + 24;
            // do 64 bit compare to detect bits beyond 15 being set
            tempCS = CS; // zero padded to 64 bit
            if tempCS != tempSsCS {
                #CP(FAR-RET/IRET);
            }
            // do 64 bit compare; pad CSBASE+RIP with 0 for 32 bit LIP
            if CSBASE + RIP != tempSsLIP {
                #CP(FAR-RET/IRET);
            }
            // check if 4 byte aligned
            if tempSSP &amp;&amp; 0x3 != 0 {
                #CP(FAR-RET/IRET);
            }
        }
    }
    tempOldCPL = CPL;
    CPL = ReturnCodeSegmentSelector(RPL);
    ESP = tempESP;
    SS = tempSS;
    tempOldSSP = SSP;
    if ShadowStackEnabled(CPL) {
        if CPL == 3 {
            tempSSP = IA32_PL3_SSP;
        }
        if (CS.L == 0 &amp;&amp; tempSSP[32..=63] != 0)
                || (CS.L == 1 &amp;&amp; /* tempSSP is not canonical relative to the current paging mode */) {
            #GP(0);
        }
        SSP = tempSSP;
    }
    // Now past all faulting points; safe to free the token. The token free is done using the old SSP
    // and using a supervisor override as old CPL was a supervisor privilege level
    if ShadowStackEnabled(tempOldCPL) {
        expected_token_value = tempOldSSP | BUSY_BIT; // busy bit - bit position 0 - must be set
        new_token_value = tempOldSSP; // clear the busy bit
        shadow_stack_lock_cmpxchg8b(tempOldSSP, new_token_value, expected_token_value);
    }
    for each of segment register (ES, FS, GS, and DS) {
        if /* segment register points to data or non-conforming code segment */
                &amp;&amp; CPL &gt; segment descriptor DPL {
            // DPL in hidden part of segment register
            SegmentSelector = 0; // SegmentSelector invalid
        }
    }
    if /* instruction has immediate operand */ {
        // release parameters from calling procedure's stack
        if StackAddressSize == 32 {
            ESP = ESP + SRC;
        } else {
            if StackAddressSize == 16 {
                SP = SP + SRC;
            } else { // StackAddressSize == 64
                RSP = RSP + SRC;
            }
        }
    }
}
</code></pre>
<h2 id="flags-affected-23"><a class="header" href="#flags-affected-23">Flags Affected</a></h2>
<p>None.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="miscellaneous-instructions-1"><a class="header" href="#miscellaneous-instructions-1">Miscellaneous Instructions</a></h1>
<!-- ANCHOR: table -->
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Mnemonic</th><th style="text-align: left">Summary</th></tr></thead><tbody>
<tr><td style="text-align: left"><a href="instructions/miscellaneous-instructions/lea.html"><code>LEA</code></a></td><td style="text-align: left">Load Effective Address</td></tr>
<tr><td style="text-align: left"><a href="instructions/miscellaneous-instructions/nop.html"><code>NOP</code></a></td><td style="text-align: left">No Operation</td></tr>
</tbody></table>
</div><!-- ANCHOR_END:table -->
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="lea"><a class="header" href="#lea"><code>LEA</code></a></h1>
<p>Load Effective Address</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Instruction</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>LEA r16, m</code></td><td style="text-align: left">Store effective address for <code>m</code> in <code>r16</code></td></tr>
<tr><td style="text-align: left"><code>LEA r32, m</code></td><td style="text-align: left">Store effective address for <code>m</code> in <code>r32</code></td></tr>
<tr><td style="text-align: left"><code>LEA r64, m</code></td><td style="text-align: left">Store effective address for <code>m</code> in <code>r64</code></td></tr>
</tbody></table>
</div>
<h2 id="description-24"><a class="header" href="#description-24">Description</a></h2>
<p>Computes the effective address of the second operand (the source operand) and stores it in the first operand (destination operand). The source operand is a memory address (offset part) specified with one of the processors addressing modes; the destination operand is a general-purpose register. The address-size and operand-size attributes affect the action performed by this instruction, as shown in the following table. The operand-size attribute of the instruction is determined by the chosen register; the address-size attribute is determined by the attribute of the code segment.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Operand Size</th><th style="text-align: left">Address Size</th><th style="text-align: left">Action Performed</th></tr></thead><tbody>
<tr><td style="text-align: left">16</td><td style="text-align: left">16</td><td style="text-align: left">16-bit effective address is calculated and stored in requested 16-bit register destination.</td></tr>
<tr><td style="text-align: left">16</td><td style="text-align: left">32</td><td style="text-align: left">32-bit effective address is calculated. The lower 16 bits of the address are stored in the requested 16-bit register destination.</td></tr>
<tr><td style="text-align: left">32</td><td style="text-align: left">16</td><td style="text-align: left">16-bit effective address is calculated. The 16-bit address is zero-extended and stored in the requested 32-bit register destination.</td></tr>
<tr><td style="text-align: left">32</td><td style="text-align: left">32</td><td style="text-align: left">32-bit effective address is calculated and stored in the requested 32-bit register destination.</td></tr>
</tbody></table>
</div>
<p>Different assemblers may use different algorithms based on the size attribute and symbolic reference of the source operand.</p>
<p>In 64-bit mode, the instruction’s destination operand is governed by operand size attribute, the default operand size is 32 bits. Address calculation is governed by address size attribute, the default address size is 64-bits. In 64-bit mode, address size of 16 bits is not encodable. See the table below.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Operand Size</th><th style="text-align: left">Address Size</th><th style="text-align: left">Action Performed</th></tr></thead><tbody>
<tr><td style="text-align: left">16</td><td style="text-align: left">32</td><td style="text-align: left">32-bit effective address is calculated (using <code>0x67</code> prefix). The lower 16 bits of the address are stored in the requested 16-bit register destination (using <code>0x66</code> prefix).</td></tr>
<tr><td style="text-align: left">16</td><td style="text-align: left">64</td><td style="text-align: left">64-bit effective address is calculated (default address size). The lower 16 bits of the address are stored in the requested 16-bit register destination (using <code>0x66</code> prefix).</td></tr>
<tr><td style="text-align: left">32</td><td style="text-align: left">32</td><td style="text-align: left">32-bit effective address is calculated (using <code>0x67</code> prefix) and stored in the requested 32-bit register destination.</td></tr>
<tr><td style="text-align: left">32</td><td style="text-align: left">64</td><td style="text-align: left">64-bit effective address is calculated (default address size) and the lower 32 bits of the address are stored in the requested 32-bit register destination.</td></tr>
<tr><td style="text-align: left">64</td><td style="text-align: left">32</td><td style="text-align: left">32-bit effective address is calculated (using <code>0x67</code> prefix), zero-extended to 64-bits, and stored in the requested 64-bit register destination (using <code>REX.W</code>).</td></tr>
<tr><td style="text-align: left">64</td><td style="text-align: left">64</td><td style="text-align: left">64-bit effective address is calculated (default address size) and all 64-bits of the address are stored in the requested 64-bit register destination (using <code>REX.W</code>).</td></tr>
</tbody></table>
</div>
<h2 id="operation-25"><a class="header" href="#operation-25">Operation</a></h2>
<p><code>DEST</code>: first operand<br />
<code>SRC</code>: second operand</p>
<h3 id="operandsize--16-5"><a class="header" href="#operandsize--16-5">OperandSize = 16</a></h3>
<pre><code class="language-rust ignore">if AddressSize == 16 {
    DEST = EffectiveAddress(SRC); // 16-bit address
} else if AddressSize == 32 {
    temp = EffectiveAddress(SRC); // 32-bit address
    DEST = temp[0..=15]; // 16-bit address
} else if AddressSize == 64 {
    temp = EffectiveAddress(SRC); // 64-bit address
    DEST = temp[0..=15]; // 16-bit address
}
</code></pre>
<h3 id="operandsize--32-5"><a class="header" href="#operandsize--32-5">OperandSize = 32</a></h3>
<pre><code class="language-rust ignore">if AddressSize == 16 {
    temp = EffectiveAddress(SRC); // 16-bit address
    DEST = ZeroExtend(temp); // 32-bit address
} else if AddressSize == 32 {
    DEST = EffectiveAddress(SRC); // 32-bit address
} else if AddressSize == 64 {
    temp = EffectiveAddress(SRC); // 64-bit address
    DEST = temp[0..=31]; // 16-bit address
}
</code></pre>
<h3 id="operandsize--64-5"><a class="header" href="#operandsize--64-5">OperandSize = 64</a></h3>
<pre><code class="language-rust ignore">if AddressSize == 64 {
    DEST = EffectiveAddress(SRC); // 64-bit address
}
</code></pre>
<h2 id="flags-affected-24"><a class="header" href="#flags-affected-24">Flags Affected</a></h2>
<p>None.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="nop"><a class="header" href="#nop"><code>NOP</code></a></h1>
<p>No Operation</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Instruction</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>NOP</code></td><td style="text-align: left">One byte no-operation instruction</td></tr>
<tr><td style="text-align: left"><code>NOP r/m16</code></td><td style="text-align: left">Multi-byte no-operation instruction</td></tr>
<tr><td style="text-align: left"><code>NOP r/m32</code></td><td style="text-align: left">Multi-byte no-operation instruction</td></tr>
</tbody></table>
</div>
<h2 id="description-25"><a class="header" href="#description-25">Description</a></h2>
<p>This instruction performs no operation. It is a one-byte or multi-byte NOP that takes up space in the instruction stream but does not impact machine context, except for the EIP register.</p>
<p>The multi-byte form of NOP is available on processors with model encoding:</p>
<ul>
<li><code>CPUID.01H.EAX[Bytes 11:8]</code> = <code>0b0110</code> or <code>0b1111</code>
The multi-byte <code>NOP</code> instruction does not alter the content of a register and will not issue a memory operation. The instruction’s operation is the same in non-64-bit modes and 64-bit mode.</li>
</ul>
<h2 id="operation-26"><a class="header" href="#operation-26">Operation</a></h2>
<p>The one-byte <code>NOP</code> instruction is an alias mnemonic for the <code>XCHG (E)AX, (E)AX</code> instruction.</p>
<p>The multi-byte <code>NOP</code> instruction performs no operation on supported processors and generates undefined opcode exception on processors that do not support the multi-byte <code>NOP</code> instruction.</p>
<p>The memory operand form of the instruction allows software to create a byte sequence of “no operation” as one instruction. For situations where multiple-byte <code>NOP</code>s are needed, the recommended operations (32-bit mode and 64-bit mode) are:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Length</th><th style="text-align: left">Assembly</th><th style="text-align: left">Byte Sequence</th></tr></thead><tbody>
<tr><td style="text-align: left">2 bytes</td><td style="text-align: left"><code>66 nop</code></td><td style="text-align: left"><code>66 90</code></td></tr>
<tr><td style="text-align: left">3 bytes</td><td style="text-align: left"><code>nop DWORD ptr [eax]</code></td><td style="text-align: left"><code>0F 1F 00</code></td></tr>
<tr><td style="text-align: left">4 bytes</td><td style="text-align: left"><code>nop DWORD ptr [eax + 0x00]</code></td><td style="text-align: left"><code>0F 1F 40 00</code></td></tr>
<tr><td style="text-align: left">5 bytes</td><td style="text-align: left"><code>nop DWORD ptr [eax + eax*1 + 0x00]</code></td><td style="text-align: left"><code>0F 1F 44 00 00</code></td></tr>
<tr><td style="text-align: left">6 bytes</td><td style="text-align: left"><code>66 nop DWORD ptr [eax + eax*1 + 0x00]</code></td><td style="text-align: left"><code>66 0F 1F 44 00 00</code></td></tr>
<tr><td style="text-align: left">7 bytes</td><td style="text-align: left"><code>nop DWORD ptr [eax + 0x0000_0000]</code></td><td style="text-align: left"><code>0F 1F 80 00 00 00 00</code></td></tr>
<tr><td style="text-align: left">8 bytes</td><td style="text-align: left"><code>nop DWORD ptr [eax + eax*1 + 0x0000_0000]</code></td><td style="text-align: left"><code>0F 1F 84 00 00 00 00 00</code></td></tr>
<tr><td style="text-align: left">9 bytes</td><td style="text-align: left"><code>66 nop DWORD ptr [eax + eax*1 + 0x0000_0000]</code></td><td style="text-align: left"><code>66 0F 1F 84 00 00 00 00 00</code></td></tr>
</tbody></table>
</div>
<h2 id="flags-affected-25"><a class="header" href="#flags-affected-25">Flags Affected</a></h2>
<p>None.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="system-v-abi"><a class="header" href="#system-v-abi">System V ABI</a></h1>
<h2 id="callee-saved"><a class="header" href="#callee-saved">Callee saved</a></h2>
<p><code>rbx</code>, <code>rbp</code>, <code>rsp</code>, <code>r12</code>, <code>r13</code>, <code>r14</code>, <code>r15</code></p>
<p>need to be saved and restored inside function</p>
<h2 id="caller-saved"><a class="header" href="#caller-saved">Caller saved</a></h2>
<p><code>rax</code>, <code>rcx</code>, <code>rdx</code>, <code>rdi</code>, <code>rsi</code>, <code>r8</code>, <code>r9</code>, <code>r10</code>, <code>r11</code></p>
<p>can be used freely inside function</p>
<h2 id="function-parameters"><a class="header" href="#function-parameters">Function Parameters</a></h2>
<p><code>rdi</code>, <code>rsi</code>, <code>rdx</code>, <code>rcx</code>, <code>r8</code>, <code>r9</code></p>
<p>further values on stack in reverse order</p>
<h2 id="return-value"><a class="header" href="#return-value">Return Value</a></h2>
<p><code>rax</code> (128-bit: higher go in <code>rdx</code>)</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
